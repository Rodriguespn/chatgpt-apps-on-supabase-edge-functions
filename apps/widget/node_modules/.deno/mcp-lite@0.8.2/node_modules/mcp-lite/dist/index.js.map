{
  "version": 3,
  "sources": ["../src/client-request-adapter.ts", "../src/constants.ts", "../src/errors.ts", "../src/utils.ts", "../src/types.ts", "../src/validation.ts", "../src/context.ts", "../src/uri-template.ts", "../src/core.ts", "../src/session-store.ts", "../src/sse-writer.ts", "../src/transport-http/http-responses.ts", "../src/transport-http/transport-http.ts"],
  "sourcesContent": [
    "export interface ClientRequestAdapter {\n  /**\n   * Create and track a pending client request. Returns a promise that\n   * resolves when a matching JSON-RPC response is received (or rejects on timeout).\n   */\n  createPending(\n    sessionId: string | undefined,\n    requestId: string | number,\n    options?: { timeout_ms?: number },\n  ): { promise: Promise<unknown> };\n\n  /**\n   * Resolve a pending request by providing the JSON-RPC response payload.\n   * Returns true when a pending entry was found and resolved.\n   */\n  resolvePending(\n    sessionId: string | undefined,\n    requestId: string | number,\n    response: unknown,\n  ): boolean;\n\n  /**\n   * Reject a pending request (e.g., timeout/cancel). Returns true when a\n   * pending entry was found and rejected.\n   */\n  rejectPending(\n    sessionId: string | undefined,\n    requestId: string | number,\n    reason: unknown,\n  ): boolean;\n}\n\ninterface PendingEntry {\n  resolve: (value: unknown) => void;\n  reject: (reason?: unknown) => void;\n  timer?: ReturnType<typeof setTimeout>;\n}\n\nfunction makeKey(\n  sessionId: string | undefined,\n  requestId: string | number,\n): string {\n  return `${sessionId ?? \"\"}:${String(requestId)}`;\n}\n\nexport class InMemoryClientRequestAdapter implements ClientRequestAdapter {\n  private pending = new Map<string, PendingEntry>();\n  private defaultTimeoutMs?: number;\n\n  constructor(options?: { defaultTimeoutMs?: number }) {\n    this.defaultTimeoutMs = options?.defaultTimeoutMs;\n  }\n\n  createPending(\n    sessionId: string | undefined,\n    requestId: string | number,\n    options?: { timeout_ms?: number },\n  ): { promise: Promise<unknown> } {\n    const key = makeKey(sessionId, requestId);\n\n    // Check if key already exists and clean up existing entry\n    const existingEntry = this.pending.get(key);\n    if (existingEntry) {\n      if (existingEntry.timer) {\n        clearTimeout(existingEntry.timer);\n      }\n      existingEntry.reject(\n        new Error(\"Request replaced by new request with same key\"),\n      );\n      this.pending.delete(key);\n    }\n\n    let resolve!: (value: unknown) => void;\n    let reject!: (reason?: unknown) => void;\n    const promise = new Promise<unknown>((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    const entry: PendingEntry = { resolve, reject };\n\n    // Use provided timeout, or fall back to default timeout\n    const timeoutMs = options?.timeout_ms ?? this.defaultTimeoutMs;\n    if (timeoutMs && timeoutMs > 0) {\n      entry.timer = setTimeout(() => {\n        this.pending.delete(key);\n        reject(\n          new Error(\n            `Client request ${requestId} timed out after ${timeoutMs}ms`,\n          ),\n        );\n      }, timeoutMs);\n    }\n\n    this.pending.set(key, entry);\n    return { promise };\n  }\n\n  resolvePending(\n    sessionId: string | undefined,\n    requestId: string | number,\n    response: unknown,\n  ): boolean {\n    const key = makeKey(sessionId, requestId);\n    const entry = this.pending.get(key);\n    if (!entry) return false;\n    if (entry.timer) clearTimeout(entry.timer);\n    this.pending.delete(key);\n    entry.resolve(response);\n    return true;\n  }\n\n  rejectPending(\n    sessionId: string | undefined,\n    requestId: string | number,\n    reason: unknown,\n  ): boolean {\n    const key = makeKey(sessionId, requestId);\n    const entry = this.pending.get(key);\n    if (!entry) return false;\n    if (entry.timer) clearTimeout(entry.timer);\n    this.pending.delete(key);\n    entry.reject(reason);\n    return true;\n  }\n}\n",
    "export const JSON_RPC_VERSION = \"2.0\";\n\nexport const SUPPORTED_MCP_PROTOCOL_VERSIONS = {\n  V2025_03_26: \"2025-03-26\",\n  V2025_06_18: \"2025-06-18\",\n} as const;\n\nexport const SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST = Object.values(\n  SUPPORTED_MCP_PROTOCOL_VERSIONS,\n);\n\nexport const MCP_PROTOCOL_HEADER = \"MCP-Protocol-Version\";\n\nexport const MCP_SESSION_ID_HEADER = \"MCP-Session-Id\";\n\nexport const MCP_LAST_EVENT_ID_HEADER = \"Last-Event-ID\";\n\nexport const SSE_ACCEPT_HEADER = \"text/event-stream\";\n\nexport const METHODS = {\n  INITIALIZE: \"initialize\",\n  PING: \"ping\",\n  TOOLS: {\n    LIST: \"tools/list\",\n    CALL: \"tools/call\",\n  },\n  PROMPTS: {\n    LIST: \"prompts/list\",\n    GET: \"prompts/get\",\n  },\n  RESOURCES: {\n    LIST: \"resources/list\",\n    TEMPLATES_LIST: \"resources/templates/list\",\n    READ: \"resources/read\",\n    SUBSCRIBE: \"resources/subscribe\",\n    UNSUBSCRIBE: \"resources/unsubscribe\",\n  },\n  COMPLETION: {\n    COMPLETE: \"completion/complete\",\n  },\n  ELICITATION: {\n    CREATE: \"elicitation/create\",\n  },\n  SAMPLING: {\n    CREATE: \"sampling/createMessage\",\n  },\n  NOTIFICATIONS: {\n    CANCELLED: \"notifications/cancelled\",\n    INITIALIZED: \"notifications/initialized\",\n    PROGRESS: \"notifications/progress\",\n    ROOTS: {\n      LIST_CHANGED: \"notifications/roots/list_changed\",\n    },\n    TOOLS: {\n      LIST_CHANGED: \"notifications/tools/list_changed\",\n    },\n    PROMPTS: {\n      LIST_CHANGED: \"notifications/prompts/list_changed\",\n    },\n    RESOURCES: {\n      LIST_CHANGED: \"notifications/resources/list_changed\",\n    },\n  },\n  LOGGING: {\n    SET_LEVEL: \"logging/setLevel\",\n  },\n};\n\nexport const GLOBAL_NOTIFICATIONS = [\n  METHODS.NOTIFICATIONS.TOOLS.LIST_CHANGED,\n  METHODS.NOTIFICATIONS.PROMPTS.LIST_CHANGED,\n  METHODS.NOTIFICATIONS.RESOURCES.LIST_CHANGED,\n];\n\nexport const SSE_STREAM_ID = \"_GET_stream\";\n",
    "import type { JsonRpcError } from \"./types.js\";\n\nexport class RpcError extends Error {\n  public readonly code: number;\n  public readonly data?: unknown;\n  public readonly cause?: unknown;\n\n  constructor(code: number, message: string, data?: unknown, cause?: unknown) {\n    super(message);\n    this.name = \"RpcError\";\n    this.code = code;\n    this.data = data;\n    this.cause = cause;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n\n  toJson(): JsonRpcError {\n    return {\n      code: this.code,\n      message: this.message,\n      data: this.data,\n    };\n  }\n}\n",
    "import { RpcError } from \"./errors.js\";\nimport {\n  createJsonRpcError,\n  JSON_RPC_ERROR_CODES,\n  type JsonRpcId,\n  type JsonRpcRes,\n} from \"./types.js\";\n\n/**\n * Checks if a value is an object.\n * @param value - The value to check.\n * @returns True if the value is an object, false otherwise.\n */\nexport function isObject(value: unknown): value is object {\n  return typeof value === \"object\" && value !== null;\n}\n\n/**\n * Checks if a value is an object with a specific key.\n * @param value - The value to check.\n * @param key - The key to check for.\n * @returns True if the value is an object with the key, false otherwise.\n */\nexport function objectWithKey<T extends string>(\n  value: unknown,\n  key: T,\n): value is { [K in T]: unknown } {\n  return isObject(value) && key in value;\n}\n\n/**\n * Checks if a value is an object with a specific key and that the value for that key is not undefined.\n * @param value - The value to check.\n * @param key - The key to check for.\n * @returns True if the value is an object with the key that is defined, false otherwise.\n */\nexport function objectWithDefinedKey<T extends string>(\n  value: unknown,\n  key: T,\n): value is { [K in T]: Exclude<unknown, undefined> } {\n  if (!isObject(value)) {\n    return false;\n  }\n  const candidate = value as Record<string, unknown>;\n  if (!(key in candidate)) {\n    return false;\n  }\n  return candidate[key] !== undefined;\n}\n\n/**\n * Checks if a value is an object with a specific key and value.\n * @param value - The value to check.\n * @param key - The key to check for.\n * @param expectedValue - The expected value for the key.\n * @returns True if the value is an object with the key and value, false otherwise.\n */\nexport function objectWithKeyAndValue<T extends string, V>(\n  value: unknown,\n  key: T,\n  expectedValue: V,\n): value is { [K in T]: V } {\n  return objectWithKey(value, key) && value[key] === expectedValue;\n}\n\n/**\n * Checks if a value is an object with a specific key of a specific type.\n * @param value - The value to check.\n * @param key - The key to check for.\n * @param typeGuard - A type guard function to validate the value at the key.\n * @returns True if the value is an object with the key of the specified type, false otherwise.\n */\nexport function objectWithKeyOfType<T extends string, V>(\n  value: unknown,\n  key: T,\n  typeGuard: (val: unknown) => val is V,\n): value is { [K in T]: V } {\n  return objectWithKey(value, key) && typeGuard(value[key]);\n}\n\nexport function isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n\nexport function errorToResponse(\n  err: unknown,\n  requestId: JsonRpcId | undefined,\n): JsonRpcRes | null {\n  if (requestId === undefined) {\n    return null;\n  }\n\n  if (err instanceof RpcError) {\n    return createJsonRpcError(requestId, err.toJson());\n  }\n\n  const errorData =\n    err instanceof Error ? { message: err.message, stack: err.stack } : err;\n\n  return createJsonRpcError(\n    requestId,\n    new RpcError(\n      JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n      \"Internal error\",\n      errorData,\n    ).toJson(),\n  );\n}\n",
    "import type { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport type { AuthInfo } from \"./auth.js\";\nimport { GLOBAL_NOTIFICATIONS, JSON_RPC_VERSION } from \"./constants.js\";\nimport type { UriMatcher } from \"./uri-template.js\";\nimport {\n  isNumber,\n  isObject,\n  isString,\n  objectWithDefinedKey,\n  objectWithKeyAndValue,\n  objectWithKeyOfType,\n} from \"./utils.js\";\n\nexport const JSON_RPC_ERROR_CODES = {\n  PARSE_ERROR: -32700,\n  INVALID_REQUEST: -32600,\n  METHOD_NOT_FOUND: -32601,\n  INVALID_PARAMS: -32602,\n  INTERNAL_ERROR: -32603,\n} as const;\n\nexport type JsonRpcStandardErrorCode =\n  (typeof JSON_RPC_ERROR_CODES)[keyof typeof JSON_RPC_ERROR_CODES];\n\nexport type JsonRpcId = string | null;\n\nexport interface JsonRpcReq {\n  jsonrpc: typeof JSON_RPC_VERSION;\n  id: JsonRpcId;\n  method: string;\n  params?: unknown;\n}\n\nexport interface JsonRpcNotification {\n  jsonrpc: typeof JSON_RPC_VERSION;\n  method: string;\n  params?: unknown;\n}\n\nexport type JsonRpcMessage = JsonRpcReq | JsonRpcNotification;\n\nexport interface JsonRpcRes {\n  jsonrpc: typeof JSON_RPC_VERSION;\n  id: JsonRpcId;\n  result?: unknown;\n  error?: JsonRpcError;\n}\n\nexport interface JsonRpcError {\n  code: number;\n  message: string;\n  data?: unknown;\n}\n\nexport type OnError = (\n  err: unknown,\n  ctx: MCPServerContext,\n) => JsonRpcError | undefined | Promise<JsonRpcError | undefined>;\n\nexport interface InitializeParams {\n  protocolVersion: string;\n  capabilities?: {\n    elicitation?: Record<string, never>;\n    [key: string]: unknown;\n  };\n  clientInfo?: {\n    name: string;\n    version: string;\n  };\n}\n\nexport interface InitializeResult {\n  protocolVersion: string;\n  serverInfo: {\n    name: string;\n    version: string;\n  };\n  capabilities: {\n    tools?: { listChanged?: boolean };\n    prompts?: { listChanged?: boolean };\n    resources?: { listChanged?: boolean; subscribe?: boolean };\n  };\n}\n\nexport type ProgressToken = string | number;\n\nexport interface ProgressUpdate {\n  progress: number;\n  total?: number;\n  message?: string;\n}\n\nexport interface MCPServerContext {\n  request: JsonRpcMessage;\n  requestId: JsonRpcId | undefined;\n  response: JsonRpcRes | null;\n  env: Record<string, unknown>;\n  state: Record<string, unknown>;\n  /**\n   * Info on the authenticated user, if any\n   */\n  authInfo?: AuthInfo;\n  session?: { id: string; protocolVersion: string };\n  progressToken?: ProgressToken;\n  validate<T>(validator: unknown, input: unknown): T;\n  progress?(update: ProgressUpdate): Promise<void> | void;\n  client: MCPClientFeatures;\n  elicit<S extends StandardSchemaV1<unknown, unknown>>(\n    params: { message: string; schema: S },\n    options?: { timeout_ms?: number; strict?: boolean },\n  ): Promise<ElicitationResult<StandardSchemaV1.InferInput<S>>>;\n  elicit<T = Record<string, unknown>>(\n    params: { message: string; schema: unknown },\n    options?: { timeout_ms?: number; strict?: boolean },\n  ): Promise<ElicitationResult<T>>;\n  sample(\n    params: SamplingParams,\n    options?: { timeout_ms?: number },\n  ): Promise<SamplingResult>;\n}\n\nexport interface MCPClientFeatures {\n  supports(feature: ClientCapabilities | string): boolean;\n}\n\nexport type Middleware = (\n  ctx: MCPServerContext,\n  next: () => Promise<void>,\n) => Promise<void> | void;\n\nexport type MethodHandler = (\n  params: unknown,\n  ctx: MCPServerContext,\n) => Promise<unknown> | unknown;\n\nexport function isJsonRpcNotification(\n  obj: unknown,\n): obj is JsonRpcNotification {\n  if (!isObject(obj)) {\n    return false;\n  }\n\n  const candidate = obj as Record<string, unknown>;\n\n  if (candidate.jsonrpc !== \"2.0\") {\n    return false;\n  }\n\n  if (!isString(candidate.method)) {\n    return false;\n  }\n\n  if (\"id\" in candidate) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function isJsonRpcRequest(obj: unknown): obj is JsonRpcReq {\n  if (!isObject(obj)) {\n    return false;\n  }\n\n  const candidate = obj as Record<string, unknown>;\n\n  if (candidate.jsonrpc !== \"2.0\") {\n    return false;\n  }\n\n  if (!isString(candidate.method)) {\n    return false;\n  }\n\n  if (!(\"id\" in candidate)) {\n    return false;\n  }\n\n  const id = candidate.id;\n  if (!isString(id) && !isNumber(id) && id !== null) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function isJsonRpcResponse(obj: unknown): obj is JsonRpcRes {\n  if (!isObject(obj)) {\n    return false;\n  }\n\n  const candidate = obj as Record<string, unknown>;\n\n  if (candidate.jsonrpc !== \"2.0\") {\n    return false;\n  }\n\n  if (!(\"id\" in candidate)) {\n    return false;\n  }\n\n  const id = candidate.id;\n  if (!isString(id) && !isNumber(id) && id !== null) {\n    return false;\n  }\n\n  // Must have either result or error\n  if (!(\"result\" in candidate) && !(\"error\" in candidate)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function createJsonRpcResponse(\n  id: JsonRpcId,\n  result?: unknown,\n): JsonRpcRes {\n  return {\n    jsonrpc: JSON_RPC_VERSION,\n    id,\n    result,\n  };\n}\n\nexport function createJsonRpcError(\n  id: JsonRpcId,\n  error: JsonRpcError,\n): JsonRpcRes {\n  return {\n    jsonrpc: JSON_RPC_VERSION,\n    id,\n    error,\n  };\n}\n\nexport function isInitializeParams(obj: unknown): obj is InitializeParams {\n  if (!isObject(obj)) {\n    return false;\n  }\n\n  const candidate = obj as Record<string, unknown>;\n\n  if (!objectWithKeyOfType(candidate, \"protocolVersion\", isString)) {\n    return false;\n  }\n\n  if (\n    objectWithDefinedKey(candidate, \"capabilities\") &&\n    !objectWithKeyOfType(candidate, \"capabilities\", isObject)\n  ) {\n    return false;\n  }\n\n  if (objectWithDefinedKey(candidate, \"clientInfo\")) {\n    if (!objectWithKeyOfType(candidate, \"clientInfo\", isObject)) {\n      return false;\n    }\n\n    const clientInfoObj = candidate.clientInfo as Record<string, unknown>;\n\n    if (!isClientInfo(clientInfoObj)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isClientInfo(obj: unknown) {\n  if (!objectWithKeyOfType(obj, \"name\", isString)) {\n    return false;\n  }\n  if (!objectWithKeyOfType(obj, \"version\", isString)) {\n    return false;\n  }\n  return true;\n}\n\nexport interface Tool {\n  name: string;\n  description?: string;\n  inputSchema: unknown;\n  outputSchema?: unknown;\n  title?: string;\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface Prompt {\n  name: string;\n  description?: string;\n  arguments?: unknown[];\n  title?: string;\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface PromptArgumentDef {\n  name: string;\n  description?: string;\n  required?: boolean;\n}\n\nexport interface PromptMetadata {\n  name: string;\n  title?: string;\n  description?: string;\n  arguments?: PromptArgumentDef[];\n  _meta?: { [key: string]: unknown };\n}\n\nexport type PromptHandler<TArgs = unknown> = (\n  args: TArgs,\n  ctx: MCPServerContext,\n) => Promise<PromptGetResult> | PromptGetResult;\n\nexport interface PromptEntry {\n  metadata: PromptMetadata;\n  handler: PromptHandler;\n  validator?: unknown;\n}\n\nexport interface Resource {\n  uri: string;\n  name?: string;\n  description?: string;\n  mimeType?: string;\n  _meta?: { [key: string]: unknown };\n  annotations?: Annotations;\n}\n\nexport interface ResourceProvider {\n  list?: (ctx: MCPServerContext) => unknown;\n  read?: (uri: string, ctx: MCPServerContext) => unknown;\n  subscribe?: (\n    uri: string,\n    ctx: MCPServerContext,\n    onChange: (n: { uri: string }) => void,\n  ) => unknown;\n}\n\nexport interface ToolEntry {\n  metadata: Tool;\n  handler: MethodHandler;\n  validator?: unknown;\n  outputValidator?: unknown;\n}\n\nexport interface ResourceEntry {\n  metadata: Resource | ResourceTemplate;\n  handler: ResourceHandler;\n  validators?: ResourceVarValidators;\n  matcher?: UriMatcher;\n  type: \"resource\" | \"resource_template\";\n}\n\nexport type InferInput<T> = T extends StandardSchemaV1<unknown, unknown>\n  ? StandardSchemaV1.InferInput<T>\n  : unknown;\n\nexport type InferOutput<T> = T extends StandardSchemaV1<unknown, unknown>\n  ? StandardSchemaV1.InferOutput<T>\n  : unknown;\n\nexport type SchemaAdapter = (schema: StandardSchemaV1) => JsonSchema;\nexport type JsonSchema = unknown;\n\nexport function isStandardSchema(value: unknown): value is StandardSchemaV1 {\n  return (\n    value !== null &&\n    // ArkType uses functions for schemas, so we need to check whether `value` is an object or a function\n    (typeof value === \"object\" || typeof value === \"function\") &&\n    \"~standard\" in value &&\n    typeof (value as Record<string, unknown>)[\"~standard\"] === \"object\" &&\n    (value as { \"~standard\": { version: number } })[\"~standard\"].version === 1\n  );\n}\n\nexport type Role = \"user\" | \"assistant\" | \"system\";\n\nexport type ClientCapabilities = \"elicitation\" | \"roots\" | \"sampling\";\n\nexport interface Annotations {\n  audience?: Role[];\n  lastModified?: string;\n  priority?: number;\n}\n\nexport type TextResourceContents = {\n  _meta?: { [key: string]: unknown };\n  uri: string;\n  type: \"text\";\n  text: string;\n  mimeType?: string;\n};\n\nexport type BlobResourceContents = {\n  _meta?: { [key: string]: unknown };\n  uri: string;\n  blob: string;\n  mimeType?: string;\n};\n\nexport type ResourceContents = TextResourceContents | BlobResourceContents;\n\ninterface MetaAnnotated {\n  _meta?: { [key: string]: unknown };\n  annotations?: Annotations;\n}\n\ninterface TextContent extends MetaAnnotated {\n  type: \"text\";\n  text: string;\n}\n\ninterface ImageContent extends MetaAnnotated {\n  type: \"image\";\n  data: string;\n  mimeType: string;\n}\n\ninterface AudioContent extends MetaAnnotated {\n  type: \"audio\";\n  data: string;\n  mimeType: string;\n}\n\ninterface ResourceLink extends MetaAnnotated {\n  type: \"resource_link\";\n  uri: string;\n}\n\ninterface EmbeddedResource extends MetaAnnotated {\n  type: \"resource\";\n  resource: ResourceContents;\n}\n\nexport type Content =\n  | TextContent\n  | ImageContent\n  | AudioContent\n  | ResourceLink\n  | EmbeddedResource;\n\nexport interface PromptGetParams {\n  name: string;\n  arguments?: unknown;\n}\n\nexport interface ResourceReadParams {\n  uri: string;\n}\n\nexport interface ResourceSubscribeParams {\n  uri: string;\n}\n\nexport interface ToolCallResult<TStructuredContent = unknown> {\n  content: Content[];\n  isError?: boolean;\n  structuredContent?: TStructuredContent;\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface PromptGetResult {\n  description?: string;\n  messages: unknown[];\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface ResourceReadResult {\n  contents: ResourceContents[];\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface ListToolsResult {\n  tools: Tool[];\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface ListPromptsResult {\n  prompts: Prompt[];\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface ListResourcesResult {\n  resources: Resource[];\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface ListResourceTemplatesResult {\n  resourceTemplates: ResourceTemplate[];\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface ResourceTemplate {\n  uriTemplate: string;\n  name?: string;\n  description?: string;\n  mimeType?: string;\n  _meta?: { [key: string]: unknown };\n  annotations?: Annotations;\n}\n\nexport type ResourceVars = Record<string, string>;\n\nexport interface ResourceMeta {\n  name?: string;\n  description?: string;\n  mimeType?: string;\n  _meta?: { [key: string]: unknown };\n  annotations?: Annotations;\n}\n\nexport type ResourceVarValidators = Record<string, unknown>;\n\nexport type ResourceHandler = (\n  uri: URL,\n  vars: ResourceVars,\n  ctx: MCPServerContext,\n) => Promise<ResourceReadResult>;\n\nexport interface NotificationSenderOptions {\n  relatedRequestId?: string;\n}\n\nexport type NotificationSender = (\n  sessionId: string | undefined,\n  notification: { method: string; params?: unknown },\n  options?: NotificationSenderOptions,\n) => Promise<void> | void;\n\ntype GlobalNotification = (typeof GLOBAL_NOTIFICATIONS)[number];\n\nexport function isGlobalNotification(\n  notificationMethod: string,\n): notificationMethod is GlobalNotification {\n  for (const globalNotification of GLOBAL_NOTIFICATIONS) {\n    if (notificationMethod === globalNotification) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport type ElicitationAction = \"accept\" | \"decline\" | \"cancel\";\n\nexport interface ElicitationResult<TContent = Record<string, unknown>> {\n  action: ElicitationAction;\n  content?: TContent; // present on \"accept\"\n}\n\nexport type SamplingParams = {\n  /** Prompt to forward to the llm for generation */\n  prompt: string; // TODO - Support a messages array as indicated in the spec?\n  /** The system prompt to give the LLM */\n  systemPrompt?: string;\n  /** The maximum number of tokens the LLM should generate */\n  maxTokens?: number;\n  /** Preference hints for the client when forwarding request to LLM - note that the mcp client makes final decision on model selection */\n  modelPreferences?: {\n    /** A hint of which model to use, e.g., \"claude\" would allow any model from the claude fam */\n    hints?: Array<{ name: string }>;\n    /** A number 0-1, where 1 prefers more intelligent models */\n    intelligencePriority?: number;\n    /** A number 0-1, where 1 prefers faster models */\n    speedPriority?: number;\n    /** A number 0-1, where 1 prefers cheaper models */\n    costPriority?: number;\n  };\n};\n\ntype SamplingTextContent = {\n  type: \"text\";\n  text: string;\n};\n\ntype SamplingImageContent = {\n  type: \"image\";\n  /** base64 encoded image data */\n  data: string;\n  /** mimetype of the image (e.g., \"image/jpeg\") */\n  mimeType?: string;\n};\n\ntype SamplingAudioContent = {\n  type: \"audio\";\n  /** base64 encoded audio data */\n  data: string;\n  /** mimetype of the audio (e.g., \"audio/wav\") */\n  mimeType?: string;\n};\n\n/**\n * @see https://modelcontextprotocol.io/specification/2025-06-18/schema#createmessageresult\n */\nexport type SamplingResult = {\n  role: \"assistant\";\n  content: SamplingTextContent | SamplingImageContent | SamplingAudioContent;\n  model: string;\n  /** @example - \"endTurn\" */\n  stopReason?: string;\n};\n\n/**\n * Type guard for a sampling result\n *\n * @note - This only verifies the content property.\n *         Since sampling is so loosely specified, and very few clients implement it,\n *        it seems best to only validate the bare minimum here\n */\nexport function isSamplingResult(o: unknown): o is SamplingResult {\n  return objectWithKeyOfType(o, \"content\", isSamplingContent);\n}\n\nfunction isSamplingContent(o: unknown): o is SamplingResult[\"content\"] {\n  return (\n    isSamplingTextContent(o) ||\n    isSamplingImageContent(o) ||\n    isSamplingAudioContent(o)\n  );\n}\n\nfunction isSamplingTextContent(o: unknown): o is SamplingTextContent {\n  return (\n    objectWithKeyAndValue(o, \"type\", \"text\") &&\n    objectWithKeyOfType(o, \"text\", isString)\n  );\n}\n\nfunction isSamplingImageContent(o: unknown): o is SamplingImageContent {\n  return (\n    objectWithKeyAndValue(o, \"type\", \"image\") &&\n    objectWithKeyOfType(o, \"data\", isString)\n  );\n}\n\nfunction isSamplingAudioContent(o: unknown): o is SamplingAudioContent {\n  return (\n    objectWithKeyAndValue(o, \"type\", \"audio\") &&\n    objectWithKeyOfType(o, \"data\", isString)\n  );\n}\n",
    "import { RpcError } from \"./errors.js\";\nimport type { PromptArgumentDef, SchemaAdapter } from \"./types.js\";\nimport { isStandardSchema, JSON_RPC_ERROR_CODES } from \"./types.js\";\n\nexport function resolveSchema(\n  schema?: unknown,\n  schemaAdapter?: SchemaAdapter,\n): {\n  resolvedSchema: unknown;\n  validator?: unknown;\n} {\n  if (!schema) return { resolvedSchema: { type: \"object\" } };\n\n  if (isStandardSchema(schema)) {\n    if (!schemaAdapter) {\n      const vendor = schema[\"~standard\"].vendor;\n      throw new Error(\n        `Cannot use Standard Schema (vendor: \"${vendor}\") without a schema adapter. ` +\n          `Configure a schema adapter when creating McpServer.`,\n      );\n    }\n\n    const jsonSchema = schemaAdapter(schema);\n    return { resolvedSchema: jsonSchema, validator: schema };\n  }\n\n  return { resolvedSchema: schema };\n}\n\nexport function createValidationFunction<T>(\n  validator: unknown,\n  input: unknown,\n): T {\n  if (isStandardSchema(validator)) {\n    const result = validator[\"~standard\"].validate(input);\n    if (result instanceof Promise) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"Async validation not supported in this context\",\n      );\n    }\n    if (\"issues\" in result && result.issues?.length) {\n      const messages = result.issues.map((i) => i.message).join(\", \");\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        `Validation failed: ${messages}`,\n      );\n    }\n    return (result as { value: T }).value;\n  }\n\n  if (validator && typeof validator === \"object\" && \"validate\" in validator) {\n    const validatorObj = validator as {\n      validate(input: unknown): {\n        ok: boolean;\n        data?: unknown;\n        issues?: unknown[];\n      };\n    };\n    const result = validatorObj.validate(input);\n    if (result?.ok && result.data !== undefined) {\n      return result.data as T;\n    }\n    throw new RpcError(\n      JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n      \"Validation failed\",\n    );\n  }\n\n  throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, \"Invalid validator\");\n}\n\nexport function extractArgumentsFromSchema(\n  schema: unknown,\n): PromptArgumentDef[] {\n  if (!schema || typeof schema !== \"object\") {\n    return [];\n  }\n\n  const schemaObj = schema as Record<string, unknown>;\n\n  if (schemaObj.type === \"object\" && schemaObj.properties) {\n    const properties = schemaObj.properties as Record<string, unknown>;\n    const required = (schemaObj.required as string[]) || [];\n\n    return Object.entries(properties).map(([name, propSchema]) => {\n      const prop = propSchema as Record<string, unknown>;\n      return {\n        name,\n        description: prop.description as string | undefined,\n        required: required.includes(name),\n      };\n    });\n  }\n\n  return [];\n}\n\ninterface ElicitationJsonSchema {\n  type: \"object\";\n  properties: Record<string, unknown>;\n  required?: string[];\n  additionalProperties?: boolean;\n}\n\nexport function toElicitationRequestedSchema(\n  schema: unknown,\n  strict = false,\n): ElicitationJsonSchema {\n  // Handle Standard Schema inputs by converting to JSON Schema first\n  if (isStandardSchema(schema)) {\n    throw new Error(\n      \"Standard Schema inputs must be converted via resolveSchema first\",\n    );\n  }\n\n  if (!schema || typeof schema !== \"object\") {\n    if (strict) {\n      throw new Error(\"Schema must be an object\");\n    }\n    return { type: \"object\", properties: {} };\n  }\n\n  const schemaObj = schema as Record<string, unknown>;\n\n  // Ensure root is object type\n  if (schemaObj.type !== \"object\") {\n    if (strict) {\n      throw new Error(\"Root schema must be of type 'object'\");\n    }\n    return { type: \"object\", properties: {} };\n  }\n\n  if (!schemaObj.properties || typeof schemaObj.properties !== \"object\") {\n    if (strict) {\n      throw new Error(\"Object schema must have properties\");\n    }\n    return { type: \"object\", properties: {} };\n  }\n\n  const properties = schemaObj.properties as Record<string, unknown>;\n  const requiredArray = Array.isArray(schemaObj.required)\n    ? (schemaObj.required as string[])\n    : [];\n\n  const elicitationProperties: Record<string, unknown> = {};\n  const validRequired: string[] = [];\n\n  for (const [propName, propSchema] of Object.entries(properties)) {\n    const projectedProp = projectPropertyToElicitation(propSchema, strict);\n    if (projectedProp !== null) {\n      elicitationProperties[propName] = projectedProp;\n      if (requiredArray.includes(propName)) {\n        validRequired.push(propName);\n      }\n    }\n  }\n\n  const result: ElicitationJsonSchema = {\n    type: \"object\",\n    properties: elicitationProperties,\n  };\n\n  if (validRequired.length > 0) {\n    result.required = validRequired;\n  }\n\n  return result;\n}\n\nfunction projectPropertyToElicitation(\n  propSchema: unknown,\n  strict: boolean,\n): unknown | null {\n  if (!propSchema || typeof propSchema !== \"object\") {\n    if (strict) {\n      throw new Error(\"Property schema must be an object\");\n    }\n    return null;\n  }\n\n  const prop = propSchema as Record<string, unknown>;\n  const propType = prop.type;\n\n  // Handle primitive types\n  if (\n    propType === \"string\" ||\n    propType === \"number\" ||\n    propType === \"integer\" ||\n    propType === \"boolean\"\n  ) {\n    const result: Record<string, unknown> = { type: propType };\n\n    // Preserve description\n    if (typeof prop.description === \"string\") {\n      result.description = prop.description;\n    }\n\n    // Preserve default\n    if (prop.default !== undefined) {\n      result.default = prop.default;\n    }\n\n    // Handle string-specific properties\n    if (propType === \"string\") {\n      // Preserve string constraints\n      if (typeof prop.minLength === \"number\") {\n        result.minLength = prop.minLength;\n      }\n      if (typeof prop.maxLength === \"number\") {\n        result.maxLength = prop.maxLength;\n      }\n\n      // Handle string format (only supported ones)\n      if (typeof prop.format === \"string\") {\n        const supportedFormats = [\"email\", \"uri\", \"date\", \"date-time\"];\n        if (supportedFormats.includes(prop.format)) {\n          result.format = prop.format;\n        } else if (strict) {\n          throw new Error(`Unsupported string format: ${prop.format}`);\n        }\n      }\n\n      // Handle string enums with enumNames\n      if (Array.isArray(prop.enum)) {\n        const enumValues = prop.enum;\n        const enumNames = Array.isArray(prop.enumNames)\n          ? (prop.enumNames as string[])\n          : undefined;\n\n        // Only include if all enum values are strings\n        if (enumValues.every((val) => typeof val === \"string\")) {\n          result.enum = enumValues;\n          if (enumNames && enumNames.length === enumValues.length) {\n            result.enumNames = enumNames;\n          }\n        } else if (strict) {\n          throw new Error(\"Enum values must be strings for elicitation\");\n        }\n      }\n    }\n\n    // Handle number/integer constraints\n    if (propType === \"number\" || propType === \"integer\") {\n      if (typeof prop.minimum === \"number\") {\n        result.minimum = prop.minimum;\n      }\n      if (typeof prop.maximum === \"number\") {\n        result.maximum = prop.maximum;\n      }\n    }\n\n    return result;\n  }\n\n  // Drop unsupported types (arrays, objects, etc.)\n  if (strict) {\n    throw new Error(`Unsupported property type: ${propType}`);\n  }\n\n  return null;\n}\n",
    "import type { AuthInfo } from \"./auth.js\";\nimport { METHODS, SUPPORTED_MCP_PROTOCOL_VERSIONS } from \"./constants.js\";\nimport { RpcError } from \"./errors.js\";\nimport type {\n  ElicitationResult,\n  JsonRpcId,\n  JsonRpcMessage,\n  JsonRpcReq,\n  JsonRpcRes,\n  MCPServerContext,\n  ProgressToken,\n  ProgressUpdate,\n  SamplingParams,\n  SamplingResult,\n  SchemaAdapter,\n} from \"./types.js\";\nimport { isSamplingResult, JSON_RPC_ERROR_CODES } from \"./types.js\";\nimport { isObject, objectWithKey } from \"./utils.js\";\nimport {\n  createValidationFunction,\n  resolveSchema,\n  toElicitationRequestedSchema,\n} from \"./validation.js\";\n\nexport interface CreateContextOptions {\n  sessionId?: string;\n  sessionProtocolVersion?: string;\n  progressToken?: ProgressToken;\n  progressSender?: (update: ProgressUpdate) => Promise<void> | void;\n  authInfo?: AuthInfo;\n  clientCapabilities?: {\n    elicitation?: Record<string, never>;\n    roots?: Record<string, never>;\n    sampling?: Record<string, never>;\n    [key: string]: unknown;\n  };\n\n  // Add these for elicit implementation\n  schemaAdapter?: SchemaAdapter;\n  clientRequestSender?: (\n    sessionId: string | undefined,\n    request: JsonRpcReq,\n    options?: { relatedRequestId?: string | number; timeout_ms?: number },\n  ) => Promise<JsonRpcRes>;\n}\n\n/**\n * Extract progress token from a JSON-RPC message.\n */\nexport function getProgressToken(\n  message: JsonRpcMessage,\n): ProgressToken | undefined {\n  if (isObject(message.params)) {\n    const params = message.params as Record<string, unknown>;\n    const meta = params._meta as Record<string, unknown> | undefined;\n    if (objectWithKey(meta, \"progressToken\")) {\n      return meta.progressToken as ProgressToken;\n    }\n  }\n  return undefined;\n}\n\nexport function createContext(\n  message: JsonRpcMessage,\n  requestId: JsonRpcId | undefined,\n  options: CreateContextOptions = {},\n): MCPServerContext {\n  // Prefer explicit option, otherwise derive from the request message\n  const progressToken =\n    options.progressToken !== undefined\n      ? options.progressToken\n      : getProgressToken(message);\n\n  const context: MCPServerContext = {\n    request: message,\n    authInfo: options.authInfo,\n    requestId,\n    response: null,\n    env: {},\n    state: {},\n    progressToken,\n    validate: <T>(validator: unknown, input: unknown): T =>\n      createValidationFunction<T>(validator, input),\n    client: {\n      supports: (\n        feature: \"elicitation\" | \"roots\" | \"sampling\" | string,\n      ): boolean => {\n        // Real implementation will be injected in _dispatch if capabilities are available\n        if (options.clientCapabilities) {\n          return feature in options.clientCapabilities;\n        }\n        return false;\n      },\n    },\n    elicit: async (\n      params: { message: string; schema: unknown },\n      elicitOptions?: { timeout_ms?: number; strict?: boolean },\n    ): Promise<ElicitationResult> => {\n      // 1. Guard: check elicitation support\n      if (!context.client.supports(\"elicitation\")) {\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND,\n          \"Elicitation not supported by client\",\n        );\n      }\n\n      // 2. Convert schema to JSON Schema if needed\n      const { resolvedSchema } = resolveSchema(\n        params.schema,\n        options.schemaAdapter,\n      );\n\n      // 3. Project to elicitation-compatible schema\n      const requestedSchema = toElicitationRequestedSchema(\n        resolvedSchema,\n        elicitOptions?.strict,\n      );\n\n      // 4. Build JSON-RPC request\n      const elicitRequest: JsonRpcReq = {\n        jsonrpc: \"2.0\",\n        id: Math.random().toString(36).substring(7),\n        method: METHODS.ELICITATION.CREATE,\n        params: {\n          message: params.message,\n          requestedSchema,\n        },\n      };\n\n      // 5. Send request to client\n      if (!options.clientRequestSender) {\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n          \"Client request sender not configured\",\n        );\n      }\n\n      const response = await options.clientRequestSender(\n        context.session?.id,\n        elicitRequest,\n        {\n          relatedRequestId: requestId as string | number,\n          timeout_ms: elicitOptions?.timeout_ms,\n        },\n      );\n\n      // 6. Validate and return response\n      if (response.error) {\n        throw new RpcError(\n          response.error.code,\n          response.error.message,\n          response.error.data,\n        );\n      }\n\n      return response.result as ElicitationResult;\n    },\n    sample: async (\n      params: SamplingParams,\n      sampleOptions?: { timeout_ms: number },\n    ): Promise<SamplingResult> => {\n      // 1. Guard: check sampling support\n      if (!context.client.supports(\"sampling\")) {\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND,\n          \"Sampling not supported by client\",\n        );\n      }\n\n      // 2. Build JSON-RPC request\n      const samplingRequest: JsonRpcReq = {\n        jsonrpc: \"2.0\",\n        id: Math.random().toString(36).substring(7),\n        method: METHODS.SAMPLING.CREATE,\n        params: {\n          messages: [\n            {\n              role: \"user\",\n              content: {\n                type: \"text\",\n                text: params.prompt,\n              },\n            },\n          ],\n          modelPreferences: params.modelPreferences,\n          systemPrompt: params.systemPrompt,\n          maxTokens: params.maxTokens,\n        },\n      };\n\n      // 3. Send request to client\n      if (!options.clientRequestSender) {\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n          \"Client request sender not configured\",\n        );\n      }\n\n      const response = await options.clientRequestSender(\n        context.session?.id,\n        samplingRequest,\n        {\n          relatedRequestId: requestId as string | number,\n          timeout_ms: sampleOptions?.timeout_ms,\n        },\n      );\n\n      // 4. Validate and return response\n      if (response.error) {\n        throw new RpcError(\n          response.error.code,\n          response.error.message,\n          response.error.data,\n        );\n      }\n\n      if (!isSamplingResult(response.result)) {\n        // TODO - use logger once we put it on context\n        console.error(\n          \"Unexpected sampling response format from client\",\n          JSON.stringify(response.result, null, 2),\n        );\n        // TODO - Tighten up this RPC Error\n        throw new RpcError(\n          -32602, // Invalid params (investigate another error code)\n          \"Unexpected sampling response format from client\",\n        );\n      }\n\n      return response.result;\n    },\n  };\n\n  if (progressToken && options.progressSender) {\n    context.progress = async (update: ProgressUpdate): Promise<void> => {\n      await options.progressSender?.(update);\n    };\n  }\n\n  if (options.sessionId) {\n    context.session = {\n      id: options.sessionId,\n      protocolVersion:\n        options.sessionProtocolVersion ||\n        SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_03_26,\n    };\n  }\n\n  return context;\n}\n",
    "import type { ResourceVars } from \"./types.js\";\n\nexport interface UriMatcher {\n  match: (uri: string) => ResourceVars | null;\n  type: \"resource\" | \"resource_template\";\n}\n\n/**\n * Compiles a URI template into a matcher function.\n * Supports Hono-style path parameters: {name}, {name*}, and query groups {?a,b,c}\n */\nexport function compileUriTemplate(template: string): UriMatcher {\n  const isStatic = !template.includes(\"{\");\n\n  if (isStatic) {\n    return {\n      match: (uri: string) => (uri === template ? {} : null),\n      type: \"resource\",\n    };\n  }\n\n  // Extract query parameter group if present: {?param1,param2}\n  const queryMatch = template.match(/\\{\\?([^}]+)\\}/);\n  const queryParams = queryMatch?.[1]\n    ? queryMatch[1].split(\",\").map((p) => p.trim())\n    : [];\n\n  // Remove query group from template for path matching\n  const pathTemplate = template.replace(/\\{\\?[^}]+\\}/, \"\");\n\n  // Convert path template to regex\n  // Escape special regex characters except our placeholders\n  let escapedTemplate = pathTemplate.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n\n  // Convert placeholders to regex groups\n  escapedTemplate = escapedTemplate\n    .replace(/\\\\{([^}*]+)\\\\*\\\\}/g, \"(?<$1>.*)\") // {name*} -> greedy capture\n    .replace(/\\\\{([^}]+)\\\\}/g, \"(?<$1>[^/?]+)\"); // {name} -> non-greedy capture (allow query params)\n\n  const regex = new RegExp(`^${escapedTemplate}$`);\n\n  return {\n    match: (uri: string) => {\n      try {\n        // For templates with query params, match against the path part only\n        const [pathPart] = uri.split(\"?\");\n        const matchTarget = queryParams.length > 0 ? (pathPart ?? uri) : uri;\n\n        const pathMatch = matchTarget.match(regex);\n\n        if (!pathMatch) return null;\n\n        const vars: ResourceVars = { ...pathMatch.groups };\n\n        // Extract query parameters if specified in template\n        if (queryParams.length > 0) {\n          try {\n            const url = new URL(uri);\n            for (const param of queryParams) {\n              const value = url.searchParams.get(param);\n              if (value !== null) {\n                vars[param] = value;\n              }\n            }\n          } catch {\n            // If URL parsing fails, skip query params extraction\n          }\n        }\n\n        return vars;\n      } catch {\n        return null;\n      }\n    },\n    type: \"resource_template\",\n  };\n}\n",
    "import type { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport {\n  METHODS,\n  SUPPORTED_MCP_PROTOCOL_VERSIONS,\n  SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST,\n} from \"./constants.js\";\nimport {\n  type CreateContextOptions,\n  createContext,\n  getProgressToken,\n} from \"./context.js\";\nimport { RpcError } from \"./errors.js\";\nimport type {\n  InferOutput,\n  InitializeResult,\n  JsonRpcMessage,\n  JsonRpcNotification,\n  JsonRpcReq,\n  JsonRpcRes,\n  ListPromptsResult,\n  ListResourcesResult,\n  ListResourceTemplatesResult,\n  ListToolsResult,\n  MCPServerContext,\n  MethodHandler,\n  Middleware,\n  OnError,\n  PromptArgumentDef,\n  PromptEntry,\n  PromptGetResult,\n  PromptHandler,\n  PromptMetadata,\n  Resource,\n  ResourceEntry,\n  ResourceHandler,\n  ResourceMeta,\n  ResourceReadResult,\n  ResourceTemplate,\n  ResourceVarValidators,\n  SchemaAdapter,\n  Tool,\n  ToolCallResult,\n  ToolEntry,\n} from \"./types.js\";\nimport {\n  createJsonRpcError,\n  createJsonRpcResponse,\n  isInitializeParams,\n  isJsonRpcNotification,\n  JSON_RPC_ERROR_CODES,\n} from \"./types.js\";\nimport { compileUriTemplate } from \"./uri-template.js\";\nimport { errorToResponse, isObject, isString } from \"./utils.js\";\nimport {\n  createValidationFunction,\n  extractArgumentsFromSchema,\n  resolveSchema,\n} from \"./validation.js\";\n\ntype SupportedVersion =\n  (typeof SUPPORTED_MCP_PROTOCOL_VERSIONS)[keyof typeof SUPPORTED_MCP_PROTOCOL_VERSIONS];\n\nfunction isSupportedVersion(version: string): version is SupportedVersion {\n  return SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST.includes(\n    version as SupportedVersion,\n  );\n}\n\nasync function runMiddlewares(\n  middlewares: Middleware[],\n  ctx: MCPServerContext,\n  tail: () => Promise<void>,\n): Promise<void> {\n  const dispatch = async (i: number): Promise<void> => {\n    if (i < middlewares.length) {\n      const middleware = middlewares[i];\n      if (middleware) {\n        await middleware(ctx, () => dispatch(i + 1));\n      } else {\n        await dispatch(i + 1);\n      }\n    } else {\n      await tail();\n    }\n  };\n  await dispatch(0);\n}\n\n/**\n * Logger interface for MCP server internal logging.\n * Defaults to console if not provided.\n */\nexport interface Logger {\n  error(message: string, ...args: unknown[]): void;\n  warn(message: string, ...args: unknown[]): void;\n  info(message: string, ...args: unknown[]): void;\n  debug(message: string, ...args: unknown[]): void;\n}\n\nexport interface McpServerOptions {\n  name: string;\n  version: string;\n  /**\n   * A function that converts a StandardSchema to a JSON Schema\n   *\n   * In practice, you will need to coerce the `schema` parameter of this function to the correct type for the library you are using,\n   * in order to pass it to a helper that handles converting to JSON Schema.\n   *\n   * @example Using Zod\n   * ```typescript\n   * import { z } from \"zod\";\n   *\n   * const server = new McpServer({\n   *   // ...\n   *   schemaAdapter: (schema) => z.toJSONSchema(schema as z.ZodType),\n   * });\n   * ```\n   */\n  schemaAdapter?: SchemaAdapter;\n  /**\n   * Logger for internal server messages.\n   * Defaults to console if not provided.\n   *\n   * @example Using a custom logger\n   * ```typescript\n   * const server = new McpServer({\n   *   name: \"my-server\",\n   *   version: \"1.0.0\",\n   *   logger: {\n   *     error: (msg, ...args) => myLogger.error(msg, ...args),\n   *     warn: (msg, ...args) => myLogger.warn(msg, ...args),\n   *     info: (msg, ...args) => myLogger.info(msg, ...args),\n   *     debug: (msg, ...args) => myLogger.debug(msg, ...args),\n   *   }\n   * });\n   * ```\n   *\n   * @example Disabling logs\n   * ```typescript\n   * const server = new McpServer({\n   *   name: \"my-server\",\n   *   version: \"1.0.0\",\n   *   logger: {\n   *     error: () => {},\n   *     warn: () => {},\n   *     info: () => {},\n   *     debug: () => {},\n   *   }\n   * });\n   * ```\n   */\n  logger?: Logger;\n}\n\n/**\n * MCP (Model Context Protocol) Server implementation.\n *\n * Provides a framework for building MCP-compliant servers that can expose tools, prompts,\n * and resources to MCP clients. The server handles JSON-RPC 2.0 communication and protocol\n * negotiation according to the MCP specification.\n *\n * @example Basic server setup\n * ```typescript\n * import { McpServer, StreamableHttpTransport } from \"mcp-lite\";\n *\n * // Create server instance\n * const server = new McpServer({\n *   name: \"my-server\",\n *   version: \"1.0.0\"\n * });\n *\n * // Add a tool\n * server.tool(\"echo\", {\n *   description: \"Echoes the input message\",\n *   inputSchema: {\n *     type: \"object\",\n *     properties: {\n *       message: { type: \"string\" }\n *     },\n *     required: [\"message\"]\n *   },\n *   handler: (args: { message: string }) => ({\n *     content: [{ type: \"text\", text: args.message }]\n *   })\n * });\n *\n * // Create HTTP transport and bind server\n * const transport = new StreamableHttpTransport();\n * const httpHandler = transport.bind(server);\n *\n * // Use with your HTTP framework\n * app.post(\"/mcp\", async (req) => {\n *   const response = await httpHandler(req);\n *   return response;\n * });\n * ```\n *\n * @example Using middleware\n * ```typescript\n * server.use(async (ctx, next) => {\n *   console.log(\"Request:\", ctx.request.method);\n *   await next();\n *   console.log(\"Response:\", ctx.response?.result);\n * });\n * ```\n *\n * @example Tool with Standard Schema validation (Zod, Valibot, etc.)\n * ```typescript\n * import { z } from \"zod\";\n *\n * const inputSchema = z.object({\n *   value: z.number()\n * });\n *\n * server.tool(\"double\", {\n *   description: \"Doubles a number\",\n *   inputSchema, // Standard Schema validator\n *   handler: (args: { value: number }) => ({\n *     content: [{ type: \"text\", text: String(args.value * 2) }]\n *   })\n * });\n * ```\n *\n * @example Error handling\n * ```typescript\n * server.onError((error, ctx) => {\n *   console.error(\"Error in request:\", ctx.requestId, error);\n *   return {\n *     code: -32000,\n *     message: \"Custom error message\",\n *     data: { requestId: ctx.requestId }\n *   };\n * });\n * ```\n *\n * ## Core Features\n *\n * ### Tools\n * Tools are functions that can be called by MCP clients. They must return content in the\n * `ToolCallResult` format with a `content` array.\n *\n * ### Input Validation\n * - **JSON Schema**: Standard JSON Schema objects for validation\n * - **Standard Schema**: Support for Zod, Valibot, and other Standard Schema validators\n * - **No Schema**: Basic object validation when no schema provided\n *\n * ### Middleware Support\n * Middleware functions run before request handlers and can modify context, add logging,\n * implement authentication, etc.\n *\n * ### Transport Agnostic\n * The server core is transport-agnostic. Use `StreamableHttpTransport` for HTTP/REST\n * or implement custom transports for WebSockets, stdio, etc.\n *\n * ### Protocol Compliance\n * - Full MCP specification compliance\n * - JSON-RPC 2.0 protocol support\n * - Protocol version negotiation\n * - Proper error codes and messages\n *\n * @see {@link StreamableHttpTransport} For HTTP transport implementation\n * @see {@link Middleware} For middleware function signature\n * @see {@link ToolCallResult} For tool return value format\n * @see {@link MCPServerContext} For request context interface\n */\nexport class McpServer {\n  private methods: Record<string, MethodHandler> = {};\n  private initialized = false;\n  private serverInfo: { name: string; version: string };\n  private middlewares: Middleware[] = [];\n  private capabilities: InitializeResult[\"capabilities\"] = {};\n  private onErrorHandler?: OnError;\n  private schemaAdapter?: SchemaAdapter;\n  private logger: Logger;\n\n  private tools = new Map<string, ToolEntry>();\n  private prompts = new Map<string, PromptEntry>();\n  private resources = new Map<string, ResourceEntry>();\n\n  private notificationSender?: (\n    sessionId: string | undefined,\n    notification: { method: string; params?: unknown },\n    options?: { relatedRequestId?: string },\n  ) => Promise<void> | void;\n\n  private clientRequestSender?: (\n    sessionId: string | undefined,\n    request: JsonRpcReq,\n    options?: { relatedRequestId?: string | number; timeout_ms?: number },\n  ) => Promise<JsonRpcRes>;\n\n  /**\n   * Create a new MCP server instance.\n   *\n   * @param options - Server configuration options\n   * @param options.name - Server name (included in server info)\n   * @param options.version - Server version (included in server info)\n   *\n   * @example\n   * ```typescript\n   * const server = new McpServer({\n   *   name: \"my-awesome-server\",\n   *   version: \"1.2.3\"\n   * });\n   * ```\n   */\n  constructor(options: McpServerOptions) {\n    this.serverInfo = {\n      name: options.name,\n      version: options.version,\n    };\n    this.schemaAdapter = options.schemaAdapter;\n    this.logger = options.logger || console;\n\n    this.methods = {\n      [METHODS.INITIALIZE]: this.handleInitialize.bind(this),\n      [METHODS.PING]: this.handlePing.bind(this),\n      [METHODS.TOOLS.LIST]: this.handleToolsList.bind(this),\n      [METHODS.TOOLS.CALL]: this.handleToolsCall.bind(this),\n      [METHODS.PROMPTS.LIST]: this.handlePromptsList.bind(this),\n      [METHODS.PROMPTS.GET]: this.handlePromptsGet.bind(this),\n      [METHODS.RESOURCES.LIST]: this.handleResourcesList.bind(this),\n      [METHODS.RESOURCES.TEMPLATES_LIST]:\n        this.handleResourceTemplatesList.bind(this),\n      [METHODS.RESOURCES.READ]: this.handleResourcesRead.bind(this),\n      [METHODS.RESOURCES.SUBSCRIBE]: this.handleNotImplemented.bind(this),\n      [METHODS.NOTIFICATIONS.CANCELLED]:\n        this.handleNotificationCancelled.bind(this),\n      [METHODS.NOTIFICATIONS.INITIALIZED]:\n        this.handleNotificationInitialized.bind(this),\n      [METHODS.NOTIFICATIONS.PROGRESS]:\n        this.handleNotificationProgress.bind(this),\n      [METHODS.NOTIFICATIONS.ROOTS.LIST_CHANGED]:\n        this.handleNotificationRootsListChanged.bind(this),\n      [METHODS.LOGGING.SET_LEVEL]: this.handleLoggingSetLevel.bind(this),\n      [METHODS.RESOURCES.UNSUBSCRIBE]: this.handleNotImplemented.bind(this),\n      [METHODS.COMPLETION.COMPLETE]: this.handleNotImplemented.bind(this),\n    };\n  }\n\n  /**\n   * Add middleware to the server request pipeline.\n   *\n   * Middleware functions execute in the order they are added, before the actual\n   * request handler. They can modify the context, implement authentication,\n   * add logging, etc.\n   *\n   * @param middleware - Middleware function to add\n   * @returns This server instance for chaining\n   *\n   * @example\n   * ```typescript\n   * server.use(async (ctx, next) => {\n   *   console.log(`Received ${ctx.request.method} request`);\n   *   ctx.state.startTime = Date.now();\n   *   await next();\n   *   console.log(`Request took ${Date.now() - ctx.state.startTime}ms`);\n   *   if (ctx.response?.result) {\n   *     console.log(\"Tool executed successfully:\", ctx.response.result);\n   *   }\n   * });\n   * ```\n   */\n  use(middleware: Middleware): this {\n    this.middlewares.push(middleware);\n    return this;\n  }\n\n  /**\n   * Set a custom error handler for the server.\n   *\n   * The error handler receives all unhandled errors and can return custom\n   * JSON-RPC error responses or return undefined to use default error handling.\n   *\n   * @param handler - Error handler function\n   * @returns This server instance for chaining\n   *\n   * @example\n   * ```typescript\n   * server.onError((error, ctx) => {\n   *   if (error instanceof AuthError) {\n   *     return {\n   *       code: -32001,\n   *       message: \"Authentication required\",\n   *       data: { requestId: ctx.requestId }\n   *     };\n   *   }\n   *   // Return undefined for default error handling\n   * });\n   * ```\n   */\n  onError(handler: OnError): this {\n    this.onErrorHandler = handler;\n    return this;\n  }\n\n  /**\n   * Register a tool that clients can call.\n   *\n   * Tools are functions exposed to MCP clients. They receive validated arguments\n   * and must return content in the ToolCallResult format.\n   *\n   * @template TArgs - Type of the tool's input arguments\n   * @template TOutput - Type of the structured content output\n   * @param name - Unique tool name\n   * @param def - Tool definition with schema, description, handler, and optional metadata\n   * @param def.description - Human-readable description of what the tool does\n   * @param def.title - Optional display title for the tool\n   * @param def._meta - Optional arbitrary metadata object passed through to clients via tools/list\n   * @param def.inputSchema - Schema for validating input arguments (JSON Schema or Standard Schema)\n   * @param def.outputSchema - Schema for validating structured output (JSON Schema or Standard Schema)\n   * @param def.handler - Function that executes the tool logic\n   * @returns This server instance for chaining\n   *\n   * @example With JSON Schema\n   * ```typescript\n   * server.tool(\"calculateSum\", {\n   *   description: \"Calculates the sum of two numbers\",\n   *   inputSchema: {\n   *     type: \"object\",\n   *     properties: {\n   *       a: { type: \"number\" },\n   *       b: { type: \"number\" }\n   *     },\n   *     required: [\"a\", \"b\"]\n   *   },\n   *   handler: (args: { a: number; b: number }) => ({\n   *     content: [{ type: \"text\", text: String(args.a + args.b) }]\n   *   })\n   * });\n   * ```\n   *\n   * @example With Standard Schema (Zod) - Full type inference\n   * ```typescript\n   * import { z } from \"zod\";\n   *\n   * const inputSchema = z.object({\n   *   location: z.string()\n   * });\n   *\n   * const outputSchema = z.object({\n   *   temperature: z.number(),\n   *   conditions: z.string()\n   * });\n   *\n   * server.tool(\"getWeather\", {\n   *   description: \"Get weather for a location\",\n   *   inputSchema,\n   *   outputSchema,\n   *   handler: (args) => ({\n   *     // args.location is typed as string \n   *     content: [{ type: \"text\", text: \"Weather data\" }],\n   *     structuredContent: {\n   *       temperature: 22,\n   *       conditions: \"sunny\"\n   *       // Typed and validated! \n   *     }\n   *   })\n   * });\n   * ```\n   *\n   * @example Without schema\n   * ```typescript\n   * server.tool(\"ping\", {\n   *   description: \"Simple ping tool\",\n   *   handler: () => ({\n   *     content: [{ type: \"text\", text: \"pong\" }]\n   *   })\n   * });\n   * ```\n   *\n   * @example With metadata\n   * ```typescript\n   * server.tool(\"experimental-feature\", {\n   *   description: \"An experimental feature\",\n   *   title: \"Experimental Feature\",\n   *   _meta: {\n   *     version: \"0.1.0\",\n   *     stability: \"experimental\",\n   *     tags: [\"beta\", \"preview\"]\n   *   },\n   *   inputSchema: z.object({ input: z.string() }),\n   *   handler: (args) => ({\n   *     content: [{ type: \"text\", text: `Processing: ${args.input}` }]\n   *   })\n   * });\n   * ```\n   */\n  // Overload 1: Both input and output are Standard Schema (full type inference)\n  tool<\n    SInput extends StandardSchemaV1<unknown, unknown>,\n    SOutput extends StandardSchemaV1<unknown, unknown>,\n  >(\n    name: string,\n    def: {\n      description?: string;\n      title?: string;\n      _meta?: { [key: string]: unknown };\n      inputSchema: SInput;\n      outputSchema: SOutput;\n      handler: (\n        args: InferOutput<SInput>,\n        ctx: MCPServerContext,\n      ) =>\n        | Promise<ToolCallResult<InferOutput<SOutput>>>\n        | ToolCallResult<InferOutput<SOutput>>;\n    },\n  ): this;\n\n  // Overload 2: Input is Standard Schema, output is JSON Schema or undefined\n  tool<S extends StandardSchemaV1<unknown, unknown>>(\n    name: string,\n    def: {\n      description?: string;\n      title?: string;\n      _meta?: { [key: string]: unknown };\n      inputSchema: S;\n      outputSchema?: unknown;\n      handler: (\n        args: InferOutput<S>,\n        ctx: MCPServerContext,\n      ) => Promise<ToolCallResult> | ToolCallResult;\n    },\n  ): this;\n\n  // Overload 3: Output is Standard Schema, input is JSON Schema or undefined\n  tool<S extends StandardSchemaV1<unknown, unknown>>(\n    name: string,\n    def: {\n      description?: string;\n      title?: string;\n      _meta?: { [key: string]: unknown };\n      inputSchema?: unknown;\n      outputSchema: S;\n      handler: (\n        args: unknown,\n        ctx: MCPServerContext,\n      ) =>\n        | Promise<ToolCallResult<InferOutput<S>>>\n        | ToolCallResult<InferOutput<S>>;\n    },\n  ): this;\n\n  // Overload 4: JSON Schema or no schema (requires manual typing)\n  tool<TArgs = unknown, TOutput = unknown>(\n    name: string,\n    def: {\n      description?: string;\n      title?: string;\n      _meta?: { [key: string]: unknown };\n      inputSchema?: unknown;\n      outputSchema?: unknown;\n      handler: (\n        args: TArgs,\n        ctx: MCPServerContext,\n      ) => Promise<ToolCallResult<TOutput>> | ToolCallResult<TOutput>;\n    },\n  ): this;\n\n  // Implementation\n  tool<TArgs = unknown>(\n    name: string,\n    def: {\n      description?: string;\n      title?: string;\n      _meta?: { [key: string]: unknown };\n      inputSchema?: unknown | StandardSchemaV1<TArgs>;\n      outputSchema?: unknown | StandardSchemaV1<unknown>;\n      handler: (\n        args: TArgs,\n        ctx: MCPServerContext,\n      ) => Promise<ToolCallResult> | ToolCallResult;\n    },\n  ): this {\n    if (!this.capabilities.tools) {\n      this.capabilities.tools = { listChanged: true };\n    }\n\n    const { resolvedSchema, validator } = resolveSchema(\n      def.inputSchema,\n      this.schemaAdapter,\n    );\n\n    const outputSchemaResolved = resolveSchema(\n      def.outputSchema,\n      this.schemaAdapter,\n    );\n\n    const metadata: Tool = {\n      name,\n      inputSchema: resolvedSchema,\n    };\n    if (def.description) {\n      metadata.description = def.description;\n    }\n    if (def.title) {\n      metadata.title = def.title;\n    }\n    if (def._meta) {\n      metadata._meta = def._meta;\n    }\n    if (outputSchemaResolved.resolvedSchema && def.outputSchema) {\n      metadata.outputSchema = outputSchemaResolved.resolvedSchema;\n    }\n\n    const entry: ToolEntry = {\n      metadata,\n      // TODO - We could avoid this cast if MethodHandler had a generic type for `params` that defaulted to unknown, but here we could pass TArgs\n      handler: def.handler as MethodHandler,\n      validator,\n      outputValidator: outputSchemaResolved.validator,\n    };\n    this.tools.set(name, entry);\n    if (this.initialized) {\n      this.notificationSender?.(undefined, {\n        method: METHODS.NOTIFICATIONS.TOOLS.LIST_CHANGED,\n      });\n    }\n    return this;\n  }\n\n  /**\n   * Register a resource that clients can list and read.\n   *\n   * Resources are URI-identified content that can be static or template-based.\n   * Templates support parameter extraction using Hono-style syntax.\n   *\n   * @param template - URI template string (e.g. \"file://config.json\" or \"github://repos/{owner}/{repo}\")\n   * @param meta - Resource metadata for listing\n   * @param meta.name - Human-readable name for the resource\n   * @param meta.description - Description of what the resource contains\n   * @param meta.mimeType - MIME type of the resource content\n   * @param meta._meta - Optional arbitrary metadata object passed through to clients via resources/list\n   * @param meta.annotations - Optional annotations for the resource\n   * @param handler - Function that returns resource content\n   * @returns This server instance for chaining\n   *\n   * @example Static resource\n   * ```typescript\n   * server.resource(\n   *   \"file://config.json\",\n   *   { description: \"App configuration\", mimeType: \"application/json\" },\n   *   async (uri) => ({\n   *     contents: [{ uri: uri.href, text: JSON.stringify(config) }]\n   *   })\n   * );\n   * ```\n   *\n   * @example Template resource\n   * ```typescript\n   * server.resource(\n   *   \"github://repos/{owner}/{repo}\",\n   *   { description: \"GitHub repository\" },\n   *   async (uri, { owner, repo }) => ({\n   *     contents: [{ uri: uri.href, text: await fetchRepo(owner, repo) }]\n   *   })\n   * );\n   * ```\n   *\n   * @example Resource with metadata\n   * ```typescript\n   * server.resource(\n   *   \"db://records/{id}\",\n   *   {\n   *     name: \"Database Record\",\n   *     description: \"Fetch a record from the database\",\n   *     mimeType: \"application/json\",\n   *     _meta: {\n   *       cacheTtl: 300,\n   *       accessLevel: \"read-only\"\n   *     }\n   *   },\n   *   async (uri, { id }) => ({\n   *     contents: [{ uri: uri.href, text: JSON.stringify({ id, data: \"...\" }) }]\n   *   })\n   * );\n   * ```\n   */\n  resource(\n    template: string,\n    meta: ResourceMeta,\n    handler: ResourceHandler,\n  ): this;\n\n  /**\n   * Register a resource with parameter validation.\n   *\n   * @param template - URI template string with variables\n   * @param meta - Resource metadata for listing\n   * @param validators - Parameter validators (StandardSchema-compatible)\n   * @param handler - Function that returns resource content\n   * @returns This server instance for chaining\n   *\n   * @example With validation\n   * ```typescript\n   * server.resource(\n   *   \"api://users/{userId}\",\n   *   { description: \"User by ID\" },\n   *   { userId: z.string().regex(/^\\d+$/) },\n   *   async (uri, { userId }) => ({\n   *     contents: [{ uri: uri.href, text: JSON.stringify(await getUser(userId)) }]\n   *   })\n   * );\n   * ```\n   */\n  resource(\n    template: string,\n    meta: ResourceMeta,\n    validators: ResourceVarValidators,\n    handler: ResourceHandler,\n  ): this;\n\n  resource(\n    template: string,\n    meta: ResourceMeta,\n    validatorsOrHandler: ResourceVarValidators | ResourceHandler,\n    handler?: ResourceHandler,\n  ): this {\n    if (!this.capabilities.resources) {\n      this.capabilities.resources = { listChanged: true };\n    }\n\n    const actualHandler = handler || (validatorsOrHandler as ResourceHandler);\n    const validators = handler\n      ? (validatorsOrHandler as ResourceVarValidators)\n      : undefined;\n\n    const isStatic = !template.includes(\"{\");\n    const type = isStatic ? \"resource\" : \"resource_template\";\n\n    const matcher = isStatic ? undefined : compileUriTemplate(template);\n\n    const metadata = isStatic\n      ? {\n          uri: template,\n          ...meta,\n        }\n      : {\n          uriTemplate: template,\n          ...meta,\n        };\n\n    const entry: ResourceEntry = {\n      metadata,\n      handler: actualHandler,\n      validators,\n      matcher,\n      type,\n    };\n\n    this.resources.set(template, entry);\n    if (this.initialized) {\n      this.notificationSender?.(undefined, {\n        method: METHODS.NOTIFICATIONS.RESOURCES.LIST_CHANGED,\n      });\n    }\n    return this;\n  }\n\n  /**\n   * Register a prompt that clients can invoke.\n   *\n   * Prompts are templates that generate messages for LLM conversations.\n   * They can accept arguments and return a structured set of messages.\n   *\n   * @template TArgs - Type of the prompt's input arguments\n   * @param name - Unique prompt name\n   * @param def - Prompt definition with schema, description, handler, and optional metadata\n   * @param def.description - Human-readable description of what the prompt does\n   * @param def.title - Optional display title for the prompt\n   * @param def._meta - Optional arbitrary metadata object passed through to clients via prompts/list\n   * @param def.arguments - Array of argument definitions or a Standard Schema for validation\n   * @param def.inputSchema - Alternative to 'arguments' for specifying a validation schema\n   * @param def.handler - Function that generates the prompt messages\n   * @returns This server instance for chaining\n   *\n   * @example Basic prompt\n   * ```typescript\n   * server.prompt(\"greet\", {\n   *   description: \"Generate a greeting message\",\n   *   handler: () => ({\n   *     messages: [{\n   *       role: \"user\",\n   *       content: { type: \"text\", text: \"Hello, how are you?\" }\n   *     }]\n   *   })\n   * });\n   * ```\n   *\n   * @example Prompt with arguments and schema\n   * ```typescript\n   * server.prompt(\"summarize\", {\n   *   description: \"Create a summary prompt\",\n   *   arguments: z.object({\n   *     text: z.string(),\n   *     length: z.enum([\"short\", \"medium\", \"long\"]).optional()\n   *   }),\n   *   handler: (args: { text: string; length?: string }) => ({\n   *     description: \"Summarization prompt\",\n   *     messages: [{\n   *       role: \"user\",\n   *       content: {\n   *         type: \"text\",\n   *         text: `Please summarize this text in ${args.length || \"medium\"} length:\\n\\n${args.text}`\n   *       }\n   *     }]\n   *   })\n   * });\n   * ```\n   *\n   * @example Prompt with metadata\n   * ```typescript\n   * server.prompt(\"research-assistant\", {\n   *   description: \"Research assistant prompt with context\",\n   *   title: \"Research Assistant\",\n   *   _meta: {\n   *     category: \"research\",\n   *     complexity: \"advanced\",\n   *     estimatedTokens: 500\n   *   },\n   *   arguments: [\n   *     { name: \"topic\", description: \"Research topic\", required: true }\n   *   ],\n   *   handler: (args: { topic: string }) => ({\n   *     messages: [{\n   *       role: \"user\",\n   *       content: { type: \"text\", text: `Research ${args.topic}` }\n   *     }]\n   *   })\n   * });\n   * ```\n   */\n  prompt<TArgs = unknown>(\n    name: string,\n    def: {\n      title?: string;\n      description?: string;\n      _meta?: { [key: string]: unknown };\n      arguments?: unknown | StandardSchemaV1<TArgs>;\n      inputSchema?: unknown | StandardSchemaV1<TArgs>;\n      handler: PromptHandler<TArgs>;\n    },\n  ): this {\n    if (!this.capabilities.prompts) {\n      this.capabilities.prompts = { listChanged: true };\n    }\n\n    let validator: unknown;\n    let argumentDefs: PromptArgumentDef[] | undefined;\n\n    if (def.arguments) {\n      if (Array.isArray(def.arguments)) {\n        argumentDefs = def.arguments as PromptArgumentDef[];\n      } else {\n        const { resolvedSchema, validator: schemaValidator } = resolveSchema(\n          def.arguments,\n          this.schemaAdapter,\n        );\n        validator = schemaValidator;\n        argumentDefs = extractArgumentsFromSchema(resolvedSchema);\n      }\n    } else if (def.inputSchema) {\n      const { resolvedSchema, validator: schemaValidator } = resolveSchema(\n        def.inputSchema,\n        this.schemaAdapter,\n      );\n      validator = schemaValidator;\n      argumentDefs = extractArgumentsFromSchema(resolvedSchema);\n    }\n\n    const metadata: PromptMetadata = {\n      name,\n      title: def.title,\n      description: def.description,\n    };\n\n    if (argumentDefs && argumentDefs.length > 0) {\n      metadata.arguments = argumentDefs;\n    }\n\n    if (def._meta) {\n      metadata._meta = def._meta;\n    }\n\n    const entry: PromptEntry = {\n      metadata,\n      handler: def.handler as PromptHandler,\n      validator,\n    };\n\n    this.prompts.set(name, entry);\n\n    if (this.initialized) {\n      // Passing undefined here means the notification only gets broadcast to sessions\n      this.notificationSender?.(undefined, {\n        method: METHODS.NOTIFICATIONS.PROMPTS.LIST_CHANGED,\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Mount a child server into this parent server for composition.\n   *\n   * Enables modular server design by composing multiple McpServer instances.\n   * Uses keep-first semantics: first registered tool/prompt/resource wins,\n   * later duplicates are silently skipped.\n   *\n   * @param child - Child server to mount (flat, no namespacing)\n   * @returns This server instance for chaining\n   *\n   * @see {@link Logger} For configuring logging to track duplicate warnings\n   * @see {@link Middleware} For middleware composition behavior\n   *\n   * @example Flat mounting (no namespacing)\n   * ```typescript\n   * const git = new McpServer({ name: 'git', version: '1.0.0' })\n   *   .tool('clone', { handler: cloneHandler });\n   *\n   * const app = new McpServer({ name: 'app', version: '1.0.0' })\n   *   .group(git);  // tools/list shows 'clone'\n   * ```\n   *\n   * @example Complete example\n   * See examples/composing-servers for a full working example with multiple\n   * child servers, middleware composition, and real-world patterns.\n   */\n  group(child: McpServer): this;\n\n  /**\n   * Mount a child server with namespaced tools and prompts.\n   *\n   * @param prefix - Namespace prefix (e.g., 'git' makes 'clone'  'git/clone')\n   * @param child - Child server to mount\n   * @returns This server instance for chaining\n   *\n   * @see {@link Logger} For configuring logging to track duplicate warnings\n   * @see {@link Middleware} For middleware composition behavior\n   *\n   * @example Prefix namespacing\n   * ```typescript\n   * const git = new McpServer({ name: 'git', version: '1.0.0' })\n   *   .tool('clone', { handler: cloneHandler });\n   *\n   * const app = new McpServer({ name: 'app', version: '1.0.0' })\n   *   .group('git', git);  // tools/list shows 'git/clone'\n   * ```\n   *\n   * @example Complete example\n   * See examples/composing-servers for a full working example with multiple\n   * child servers, middleware composition, and real-world patterns.\n   */\n  group(prefix: string, child: McpServer): this;\n\n  /**\n   * Mount a child server with flexible namespacing options.\n   *\n   * @param options - Namespacing configuration\n   * @param child - Child server to mount\n   * @returns This server instance for chaining\n   *\n   * @see {@link Logger} For configuring logging to track duplicate warnings\n   * @see {@link Middleware} For middleware composition behavior\n   *\n   * @example Suffix namespacing\n   * ```typescript\n   * const claude = new McpServer({ name: 'claude', version: '1.0.0' })\n   *   .tool('generateText', { handler: claudeHandler });\n   *\n   * const app = new McpServer({ name: 'app', version: '1.0.0' })\n   *   .group({ suffix: 'claude' }, claude);  // tools/list shows 'generateText_claude'\n   * ```\n   *\n   * @example Both prefix and suffix\n   * ```typescript\n   * .group({ prefix: 'ai', suffix: 'v2' }, server);  // 'ai/generateText_v2'\n   * ```\n   */\n  group(options: { prefix?: string; suffix?: string }, child: McpServer): this;\n\n  group(\n    prefixOrOptionsOrChild:\n      | string\n      | { prefix?: string; suffix?: string }\n      | McpServer,\n    child?: McpServer,\n  ): this {\n    let prefix = \"\";\n    let suffix = \"\";\n    let childServer: McpServer;\n\n    if (typeof prefixOrOptionsOrChild === \"string\") {\n      // .group(\"prefix\", child)\n      prefix = prefixOrOptionsOrChild;\n      childServer = child as McpServer;\n    } else if (prefixOrOptionsOrChild instanceof McpServer) {\n      // .group(child)\n      childServer = prefixOrOptionsOrChild;\n    } else {\n      // .group({ prefix?, suffix? }, child)\n      prefix = prefixOrOptionsOrChild.prefix || \"\";\n      suffix = prefixOrOptionsOrChild.suffix || \"\";\n      childServer = child as McpServer;\n    }\n\n    this.mountChild(prefix, suffix, childServer);\n    return this;\n  }\n\n  /**\n   * Export registries snapshot for child server mounting.\n   * Used internally by .group() to compose servers.\n   * @internal\n   */\n  protected _exportRegistries(): {\n    tools: Array<{ name: string; entry: ToolEntry }>;\n    prompts: Array<{ name: string; entry: PromptEntry }>;\n    resources: Array<{ template: string; entry: ResourceEntry }>;\n  } {\n    return {\n      tools: Array.from(this.tools.entries()).map(([name, entry]) => ({\n        name,\n        entry,\n      })),\n      prompts: Array.from(this.prompts.entries()).map(([name, entry]) => ({\n        name,\n        entry,\n      })),\n      resources: Array.from(this.resources.entries()).map(\n        ([template, entry]) => ({ template, entry }),\n      ),\n    };\n  }\n\n  /**\n   * Export middlewares snapshot for child server mounting.\n   * Used internally by .group() to compose middleware chains.\n   * @internal\n   */\n  protected _exportMiddlewares(): Middleware[] {\n    return [...this.middlewares];\n  }\n\n  /**\n   * Wrap a tool or prompt handler with child middlewares for composition.\n   * Ensures child middlewares run around the handler while parent middlewares\n   * run around the entire wrapped handler.\n   * @internal\n   */\n  private wrapWithMiddlewares(\n    mws: Middleware[],\n    handler: MethodHandler,\n  ): MethodHandler {\n    return async (params, ctx) => {\n      let result: unknown;\n      let handlerCalled = false;\n\n      await runMiddlewares(mws, ctx, async () => {\n        result = await handler(params, ctx);\n        handlerCalled = true;\n      });\n\n      if (!handlerCalled) {\n        this.logger.error(\n          \"[mcp-lite] Handler was not executed. A middleware in the child server's middleware chain did not call next(). This is a server configuration issue.\",\n        );\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n          \"Internal server error\",\n        );\n      }\n\n      return result;\n    };\n  }\n\n  /**\n   * Wrap a resource handler with child middlewares for composition.\n   * Ensures child middlewares run around the handler while parent middlewares\n   * run around the entire wrapped handler.\n   * @internal\n   */\n  private wrapResourceHandler(\n    mws: Middleware[],\n    handler: ResourceHandler,\n  ): ResourceHandler {\n    return async (uri, vars, ctx) => {\n      let result: ResourceReadResult | undefined;\n      let handlerCalled = false;\n\n      await runMiddlewares(mws, ctx, async () => {\n        result = await handler(uri, vars, ctx);\n        handlerCalled = true;\n      });\n\n      if (!handlerCalled) {\n        this.logger.error(\n          \"[mcp-lite] Resource handler was not executed. A middleware in the child server's middleware chain did not call next(). This is a server configuration issue.\",\n        );\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n          \"Internal server error\",\n        );\n      }\n\n      if (!result) {\n        this.logger.error(\n          \"[mcp-lite] Resource handler returned no result. This is a server implementation issue.\",\n        );\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n          \"Internal server error\",\n        );\n      }\n\n      return result;\n    };\n  }\n\n  /**\n   * Mount a child server into this parent server.\n   * Implements keep-first semantics: first registered tool/prompt/resource wins,\n   * duplicates are silently skipped.\n   * @internal\n   */\n  private mountChild(prefix: string, suffix: string, child: McpServer): void {\n    /**\n     * Adds prefix or suffix to a tool name before mounting\n     */\n    const buildScopedName = (originalName: string) => {\n      let scopedName = originalName;\n      if (prefix) scopedName = `${prefix}/${scopedName}`;\n      if (suffix) scopedName = `${scopedName}_${suffix}`;\n      return scopedName;\n    };\n    const regs = child._exportRegistries();\n    const childMWs = child._exportMiddlewares();\n    let addedTools = 0;\n    let addedPrompts = 0;\n    let addedResources = 0;\n\n    for (const { name, entry } of regs.tools) {\n      const qualifiedName = buildScopedName(name);\n      if (!this.tools.has(qualifiedName)) {\n        const wrappedHandler =\n          childMWs.length > 0\n            ? this.wrapWithMiddlewares(childMWs, entry.handler)\n            : entry.handler;\n\n        const wrappedEntry: ToolEntry = {\n          metadata: { ...entry.metadata, name: qualifiedName },\n          handler: wrappedHandler,\n          validator: entry.validator,\n          outputValidator: entry.outputValidator,\n        };\n\n        this.tools.set(qualifiedName, wrappedEntry);\n        addedTools++;\n      } else {\n        this.logger.warn(\n          `[mcp-lite] Tool '${qualifiedName}' already exists, skipping duplicate from child server. ` +\n            `This follows keep-first semantics where the first registered tool wins.`,\n        );\n      }\n    }\n\n    for (const { name, entry } of regs.prompts) {\n      const qualifiedName = buildScopedName(name);\n      if (!this.prompts.has(qualifiedName)) {\n        const wrappedHandler =\n          childMWs.length > 0\n            ? (this.wrapWithMiddlewares(\n                childMWs,\n                entry.handler as MethodHandler,\n              ) as PromptHandler)\n            : entry.handler;\n\n        const wrappedEntry: PromptEntry = {\n          metadata: { ...entry.metadata, name: qualifiedName },\n          handler: wrappedHandler,\n          validator: entry.validator,\n        };\n\n        this.prompts.set(qualifiedName, wrappedEntry);\n        addedPrompts++;\n      } else {\n        this.logger.warn(\n          `[mcp-lite] Prompt '${qualifiedName}' already exists, skipping duplicate from child server. ` +\n            `This follows keep-first semantics where the first registered prompt wins.`,\n        );\n      }\n    }\n\n    for (const { template, entry } of regs.resources) {\n      if (!this.resources.has(template)) {\n        const wrappedHandler =\n          childMWs.length > 0\n            ? this.wrapResourceHandler(childMWs, entry.handler)\n            : entry.handler;\n\n        const wrappedEntry: ResourceEntry = {\n          ...entry,\n          handler: wrappedHandler,\n        };\n\n        this.resources.set(template, wrappedEntry);\n        addedResources++;\n      } else {\n        this.logger.warn(\n          `[mcp-lite] Resource '${template}' already exists, skipping duplicate from child server. ` +\n            `This follows keep-first semantics where the first registered resource wins.`,\n        );\n      }\n    }\n\n    if (addedTools > 0 && !this.capabilities.tools) {\n      this.capabilities.tools = { listChanged: true };\n    }\n    if (addedPrompts > 0 && !this.capabilities.prompts) {\n      this.capabilities.prompts = { listChanged: true };\n    }\n    if (addedResources > 0 && !this.capabilities.resources) {\n      this.capabilities.resources = { listChanged: true };\n    }\n\n    if (this.initialized) {\n      if (addedTools > 0) {\n        this.notificationSender?.(undefined, {\n          method: METHODS.NOTIFICATIONS.TOOLS.LIST_CHANGED,\n        });\n      }\n      if (addedPrompts > 0) {\n        this.notificationSender?.(undefined, {\n          method: METHODS.NOTIFICATIONS.PROMPTS.LIST_CHANGED,\n        });\n      }\n      if (addedResources > 0) {\n        this.notificationSender?.(undefined, {\n          method: METHODS.NOTIFICATIONS.RESOURCES.LIST_CHANGED,\n        });\n      }\n    }\n  }\n\n  /**\n   * Set the notification sender for streaming notifications.\n   * This is called by the transport to wire up notification delivery.\n   */\n  _setNotificationSender(\n    sender: (\n      sessionId: string | undefined,\n      notification: { method: string; params?: unknown },\n      options?: { relatedRequestId?: string },\n    ) => Promise<void> | void,\n  ): void {\n    this.notificationSender = sender;\n  }\n\n  /**\n   * Set the client request sender for elicitation and other client requests.\n   * This is called by the transport to wire up client request delivery.\n   */\n  _setClientRequestSender(\n    sender: (\n      sessionId: string | undefined,\n      request: JsonRpcReq,\n      options?: { relatedRequestId?: string | number; timeout_ms?: number },\n    ) => Promise<JsonRpcRes>,\n  ): void {\n    this.clientRequestSender = sender;\n  }\n\n  async _dispatch(\n    message: JsonRpcReq | JsonRpcNotification,\n    contextOptions: CreateContextOptions = {},\n  ): Promise<JsonRpcRes | null> {\n    const isNotification = isJsonRpcNotification(message);\n    const requestId = isNotification ? undefined : (message as JsonRpcReq).id;\n\n    const progressToken = getProgressToken(message as JsonRpcMessage);\n\n    const sessionId = contextOptions.sessionId;\n    const progressSender =\n      sessionId && this.notificationSender && progressToken\n        ? (update: unknown) =>\n            this.notificationSender?.(\n              sessionId,\n              {\n                method: METHODS.NOTIFICATIONS.PROGRESS,\n                params: {\n                  progressToken,\n                  ...(update as Record<string, unknown>),\n                },\n              },\n              { relatedRequestId: requestId ?? undefined },\n            )\n        : undefined;\n\n    const ctx = createContext(message as JsonRpcMessage, requestId, {\n      sessionId,\n      sessionProtocolVersion: contextOptions.sessionProtocolVersion,\n      progressToken,\n      progressSender,\n      authInfo: contextOptions.authInfo,\n      clientCapabilities: contextOptions.clientCapabilities,\n      schemaAdapter: this.schemaAdapter,\n      clientRequestSender: this.clientRequestSender,\n    });\n\n    const method = (message as JsonRpcMessage).method;\n    const handler = this.methods[method];\n\n    const tail = async (): Promise<void> => {\n      if (!handler) {\n        if (requestId === undefined) {\n          return;\n        }\n        ctx.response = createJsonRpcError(\n          requestId,\n          new RpcError(\n            JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND,\n            \"Method not found\",\n            method ? { method } : undefined,\n          ).toJson(),\n        );\n        return;\n      }\n\n      const result = await handler(message.params, ctx);\n      if (requestId !== undefined) {\n        ctx.response = createJsonRpcResponse(requestId, result);\n      }\n    };\n\n    try {\n      await runMiddlewares(this.middlewares, ctx, tail);\n\n      if (requestId === undefined) {\n        return null;\n      }\n\n      if (!ctx.response) {\n        return createJsonRpcError(\n          requestId,\n          new RpcError(\n            JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n            \"No response generated\",\n          ).toJson(),\n        );\n      }\n      return ctx.response;\n    } catch (error) {\n      if (requestId === undefined) {\n        return null;\n      }\n\n      if (this.onErrorHandler) {\n        try {\n          const customError = await this.onErrorHandler(error, ctx);\n          if (customError) {\n            return createJsonRpcError(requestId, customError);\n          }\n        } catch (_handlerError) {\n          // onError handler threw, continue with default error handling\n        }\n      }\n\n      return errorToResponse(error, requestId);\n    }\n  }\n\n  private async handleToolsList(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<ListToolsResult> {\n    return {\n      tools: Array.from(this.tools.values()).map((t) => t.metadata),\n    };\n  }\n\n  private async handleToolsCall(\n    params: unknown,\n    ctx: MCPServerContext,\n  ): Promise<ToolCallResult> {\n    if (!isObject(params)) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"tools/call requires an object with name and arguments\",\n      );\n    }\n\n    const callParams = params as Record<string, unknown>;\n\n    if (!isString(callParams.name)) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"tools/call requires a string 'name' field\",\n      );\n    }\n\n    const toolName = callParams.name;\n    const entry = this.tools.get(toolName);\n\n    if (!entry) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND,\n        \"Method not found\",\n        { method: toolName },\n      );\n    }\n\n    let validatedArgs = callParams.arguments;\n    if (entry.validator) {\n      validatedArgs = ctx.validate(entry.validator, callParams.arguments);\n    }\n\n    const result = (await entry.handler(validatedArgs, ctx)) as ToolCallResult;\n\n    // Validate structured content if outputSchema provided\n    if (\n      entry.outputValidator &&\n      \"structuredContent\" in result &&\n      !result.isError\n    ) {\n      try {\n        const validated = createValidationFunction(\n          entry.outputValidator,\n          result.structuredContent,\n        );\n        result.structuredContent = validated;\n      } catch (validationError) {\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n          `Tool '${toolName}' returned invalid structured content: ${\n            validationError instanceof Error\n              ? validationError.message\n              : String(validationError)\n          }`,\n        );\n      }\n    }\n\n    return result;\n  }\n\n  private async handlePromptsList(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<ListPromptsResult> {\n    return {\n      prompts: Array.from(this.prompts.values()).map((p) => p.metadata),\n    };\n  }\n\n  private async handlePromptsGet(\n    params: unknown,\n    ctx: MCPServerContext,\n  ): Promise<PromptGetResult> {\n    if (!isObject(params)) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"prompts/get requires an object with name and arguments\",\n      );\n    }\n\n    const getParams = params as Record<string, unknown>;\n\n    if (!isString(getParams.name)) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"prompts/get requires a string 'name' field\",\n      );\n    }\n\n    const promptName = getParams.name;\n    const entry = this.prompts.get(promptName);\n\n    if (!entry) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"Invalid prompt name\",\n        { name: promptName },\n      );\n    }\n\n    let validatedArgs = getParams.arguments || {};\n    if (entry.validator) {\n      validatedArgs = ctx.validate(entry.validator, getParams.arguments);\n    }\n\n    const result = await entry.handler(validatedArgs, ctx);\n    return result as PromptGetResult;\n  }\n\n  private async handleResourcesList(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<ListResourcesResult> {\n    const resources = Array.from(this.resources.values())\n      .filter((entry) => entry.type === \"resource\")\n      .map((entry) => entry.metadata as Resource);\n\n    return { resources };\n  }\n\n  private async handleResourceTemplatesList(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<ListResourceTemplatesResult> {\n    const resourceTemplates = Array.from(this.resources.values())\n      .filter((entry) => entry.type === \"resource_template\")\n      .map((entry) => entry.metadata as ResourceTemplate);\n\n    return { resourceTemplates };\n  }\n\n  private async handleResourcesRead(\n    params: unknown,\n    ctx: MCPServerContext,\n  ): Promise<ResourceReadResult> {\n    if (typeof params !== \"object\" || params === null) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"resources/read requires an object with uri\",\n      );\n    }\n\n    const readParams = params as Record<string, unknown>;\n\n    if (typeof readParams.uri !== \"string\") {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"resources/read requires a string 'uri' field\",\n      );\n    }\n\n    const uri = readParams.uri;\n\n    let matchedEntry: ResourceEntry | null = null;\n    let vars: Record<string, string> = {};\n\n    const directEntry = this.resources.get(uri);\n    if (directEntry?.type === \"resource\") {\n      matchedEntry = directEntry;\n    }\n\n    if (!matchedEntry) {\n      for (const entry of this.resources.values()) {\n        if (entry.type === \"resource_template\" && entry.matcher) {\n          const matchResult = entry.matcher.match(uri);\n          if (matchResult !== null) {\n            matchedEntry = entry;\n            vars = matchResult;\n            break;\n          }\n        }\n      }\n    }\n\n    if (!matchedEntry) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND,\n        \"Method not found\",\n        { uri },\n      );\n    }\n\n    let validatedVars = vars;\n    if (matchedEntry.validators) {\n      validatedVars = {};\n      for (const [key, validator] of Object.entries(matchedEntry.validators)) {\n        if (key in vars) {\n          try {\n            validatedVars[key] = ctx.validate(validator, vars[key]);\n          } catch (validationError) {\n            throw new RpcError(\n              JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n              `Validation failed for parameter '${key}': ${validationError instanceof Error ? validationError.message : String(validationError)}`,\n            );\n          }\n        }\n      }\n      for (const [key, value] of Object.entries(vars)) {\n        if (!(key in matchedEntry.validators)) {\n          validatedVars[key] = value;\n        }\n      }\n    }\n\n    try {\n      const url = { href: uri } as URL;\n      const result = await matchedEntry.handler(url, validatedVars, ctx);\n      return result;\n    } catch (error) {\n      if (error instanceof RpcError) {\n        throw error;\n      }\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n        \"Internal error\",\n        error instanceof Error ? { message: error.message } : error,\n      );\n    }\n  }\n\n  private async handleInitialize(\n    params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<InitializeResult> {\n    if (!isInitializeParams(params)) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"Invalid initialize parameters\",\n      );\n    }\n\n    const initParams = params;\n    const requested = initParams.protocolVersion;\n\n    // Determine which version to use\n    let negotiatedVersion: string;\n    if (isSupportedVersion(requested)) {\n      // Client requested a version we support - use it\n      negotiatedVersion = requested;\n    } else {\n      // Client requested unsupported version - use our most compatible version (2025-03-26)\n      // Per MCP spec: server responds with version it wants to use, client disconnects if incompatible\n      negotiatedVersion = SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_03_26;\n      this.logger?.warn?.(\n        `Client requested unsupported protocol version ${requested}, negotiating to ${negotiatedVersion}`,\n      );\n    }\n\n    this.initialized = true;\n\n    return {\n      protocolVersion: negotiatedVersion,\n      serverInfo: this.serverInfo,\n      capabilities: this.capabilities,\n    };\n  }\n\n  private async handlePing(): Promise<Record<string, never>> {\n    return {};\n  }\n\n  private async handleNotificationCancelled(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<Record<string, never>> {\n    return {};\n  }\n\n  private async handleNotificationInitialized(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<Record<string, never>> {\n    return {};\n  }\n\n  private async handleNotificationProgress(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<Record<string, never>> {\n    return {};\n  }\n\n  private async handleNotificationRootsListChanged(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<Record<string, never>> {\n    return {};\n  }\n\n  private async handleLoggingSetLevel(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<Record<string, never>> {\n    return {};\n  }\n\n  private async handleNotImplemented(\n    _params: unknown,\n    ctx: MCPServerContext,\n  ): Promise<never> {\n    throw new RpcError(JSON_RPC_ERROR_CODES.INTERNAL_ERROR, \"Not implemented\", {\n      method: ctx.request.method,\n    });\n  }\n}\n",
    "export type EventId = string;\nexport type SessionId = string;\n\nexport interface SessionMeta {\n  protocolVersion: string;\n  clientInfo?: unknown;\n  clientCapabilities?: {\n    elicitation?: Record<string, never>;\n    roots?: Record<string, never>;\n    sampling?: Record<string, never>;\n    [key: string]: unknown;\n  };\n}\n\nexport interface StreamData {\n  nextEventId: number;\n  eventBuffer: EventData[];\n}\n\nexport interface SessionData {\n  meta: SessionMeta;\n  streams: Map<string, StreamData>;\n}\n\nexport interface EventData {\n  id: EventId;\n  message: unknown;\n}\n\nfunction formatEventId(sequenceNumber: number, streamId: string): string {\n  return `${sequenceNumber}#${streamId}`;\n}\n\nfunction parseEventId(eventId: string): {\n  sequenceNumber: number;\n  streamId: string;\n} {\n  const hashIndex = eventId.lastIndexOf(\"#\");\n  if (hashIndex === -1) {\n    throw new Error(`Invalid event ID format: ${eventId}`);\n  }\n  const seqStr = eventId.slice(0, hashIndex);\n  const streamId = eventId.slice(hashIndex + 1);\n  const n = parseInt(seqStr, 10);\n  if (!Number.isFinite(n) || n < 1) {\n    throw new Error(`Invalid sequence number in event ID: ${eventId}`);\n  }\n  return {\n    sequenceNumber: n,\n    streamId,\n  };\n}\n\nexport interface SessionAdapter {\n  generateSessionId(): string;\n  create(id: SessionId, meta: SessionMeta): Promise<SessionData> | SessionData;\n  has(id: SessionId): Promise<boolean> | boolean;\n  get(\n    id: SessionId,\n  ): Promise<SessionData | undefined> | SessionData | undefined;\n  appendEvent(\n    id: SessionId,\n    streamId: string,\n    message: unknown,\n  ): Promise<EventId | undefined> | EventId | undefined;\n  replay(\n    id: SessionId,\n    lastEventId: EventId,\n    write: (eventId: EventId, message: unknown) => Promise<void> | void,\n  ): Promise<void> | void;\n  delete(id: SessionId): Promise<void> | void;\n}\n\n/**\n * InMemorySessionAdapter is a simple session adapter that stores sessions in memory.\n * It is useful for testing and development.\n * It is not recommended for production use, unless you are running a small, simple, single, and long-lived MCP server instance.\n */\nexport class InMemorySessionAdapter implements SessionAdapter {\n  #sessions = new Map<SessionId, SessionData>();\n  maxEventBufferSize: number;\n  constructor({ maxEventBufferSize }: { maxEventBufferSize: number }) {\n    this.maxEventBufferSize = maxEventBufferSize;\n  }\n\n  // TODO - make this configurable\n  generateSessionId(): string {\n    return crypto.randomUUID();\n  }\n\n  create(id: SessionId, meta: SessionMeta) {\n    const session: SessionData = {\n      meta,\n      streams: new Map(),\n    };\n    this.#sessions.set(id, session);\n    return session;\n  }\n\n  has(id: SessionId): boolean {\n    return this.#sessions.has(id);\n  }\n\n  get(id: SessionId) {\n    return this.#sessions.get(id);\n  }\n\n  delete(id: SessionId): void {\n    this.#sessions.delete(id);\n  }\n\n  appendEvent(\n    id: SessionId,\n    streamId: string,\n    message: unknown,\n  ): Promise<EventId | undefined> | EventId | undefined {\n    const session = this.get(id);\n\n    if (!session) {\n      return;\n    }\n\n    // Get or create stream data\n    let streamData = session.streams.get(streamId);\n    if (!streamData) {\n      streamData = {\n        nextEventId: 1,\n        eventBuffer: [],\n      };\n      session.streams.set(streamId, streamData);\n    }\n\n    const eventId = formatEventId(streamData.nextEventId++, streamId);\n\n    // Add to buffer with ring buffer behavior\n    streamData.eventBuffer.push({ id: eventId, message });\n\n    // Trim buffer if it exceeds max size\n    if (streamData.eventBuffer.length > this.maxEventBufferSize) {\n      streamData.eventBuffer = streamData.eventBuffer.slice(\n        -this.maxEventBufferSize,\n      );\n    }\n\n    return eventId;\n  }\n\n  async replay(\n    id: SessionId,\n    lastEventId: EventId,\n    write: (eventId: EventId, message: unknown) => Promise<void> | void,\n  ) {\n    const session = this.#sessions.get(id);\n    if (!session) {\n      return;\n    }\n\n    const { sequenceNumber: lastSeq, streamId: targetStreamId } =\n      parseEventId(lastEventId);\n\n    // Get the target stream data\n    const streamData = session.streams.get(targetStreamId);\n    if (!streamData) {\n      return;\n    }\n\n    // Replay events after lastEventId from the target stream only\n    for (const event of streamData.eventBuffer) {\n      const { sequenceNumber: eventSeq } = parseEventId(event.id);\n      if (eventSeq > lastSeq) {\n        await write(event.id, event.message);\n      }\n    }\n  }\n}\n",
    "import type { EventId } from \"./session-store.js\";\n\nexport interface StreamWriter {\n  write(message: unknown, eventId?: EventId): void;\n  end(): void;\n}\n\nexport function createSSEStream(options?: { onClose?: () => void }): {\n  stream: ReadableStream<Uint8Array>;\n  writer: StreamWriter;\n} {\n  const encoder = new TextEncoder();\n  let controller: ReadableStreamDefaultController<Uint8Array>;\n  let closed = false;\n\n  const end = (): void => {\n    if (closed) return;\n    closed = true;\n    try {\n      controller.close();\n    } catch (_error) {}\n    try {\n      options?.onClose?.();\n    } catch (_e) {}\n  };\n\n  const stream = new ReadableStream<Uint8Array>({\n    start(c) {\n      controller = c;\n    },\n    cancel() {\n      end();\n    },\n  });\n\n  const writer: StreamWriter = {\n    write(message: unknown, eventId?: EventId): void {\n      if (closed) return;\n      try {\n        let sse = \"\";\n        if (eventId) sse += `id: ${eventId}\\n`;\n        sse += `data: ${JSON.stringify(message)}\\n\\n`;\n        controller.enqueue(encoder.encode(sse));\n      } catch (_error) {\n        end();\n      }\n    },\n    end,\n  };\n\n  return { stream, writer };\n}\n",
    "import { SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST } from \"../constants.js\";\nimport { RpcError } from \"../errors.js\";\nimport {\n  createJsonRpcError,\n  JSON_RPC_ERROR_CODES,\n  type JsonRpcId,\n} from \"../types.js\";\n\nexport function respondToInvalidJsonRpc() {\n  const errorResponse = createJsonRpcError(\n    null,\n    new RpcError(\n      JSON_RPC_ERROR_CODES.INVALID_REQUEST,\n      \"Invalid JSON-RPC 2.0 message format\",\n    ).toJson(),\n  );\n\n  return new Response(JSON.stringify(errorResponse), {\n    status: 400,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n\nexport function respondToProtocolMismatch(\n  responseId: JsonRpcId,\n  protocolHeader: string,\n  expected?: string | readonly string[],\n) {\n  const expectedVersion = expected || SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST;\n  const errorResponse = createJsonRpcError(\n    responseId,\n    new RpcError(\n      JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n      \"Protocol version mismatch\",\n      {\n        expectedVersion,\n        receivedVersion: protocolHeader,\n      },\n    ).toJson(),\n  );\n\n  return new Response(JSON.stringify(errorResponse), {\n    status: 400,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n\nexport function respondToMissingProtocolHeader(responseId: JsonRpcId) {\n  const errorResponse = createJsonRpcError(\n    responseId,\n    new RpcError(\n      JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n      \"Missing required MCP-Protocol-Version header\",\n      {\n        requiredHeader: \"MCP-Protocol-Version\",\n      },\n    ).toJson(),\n  );\n\n  return new Response(JSON.stringify(errorResponse), {\n    status: 400,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n\n/**\n * Responds with a 400 bad request if the session id is missing\n * @todo - we will want to make this response configurable, so someone can use a response format more tailored to their api conventions (https://github.com/fiberplane/mcp/issues/83)\n * @note - since this validaiton happens at the transport layer, we do not respond with a JSON-RPC error\n */\nexport function respondToMissingSessionId() {\n  return new Response(\"Bad Request: Missing required session ID\", {\n    status: 400,\n    headers: {\n      \"Content-Type\": \"text/plain\",\n    },\n  });\n}\n",
    "import type { AuthInfo } from \"../auth.js\";\nimport type { ClientRequestAdapter } from \"../client-request-adapter.js\";\nimport {\n  JSON_RPC_VERSION,\n  MCP_LAST_EVENT_ID_HEADER,\n  MCP_PROTOCOL_HEADER,\n  MCP_SESSION_ID_HEADER,\n  SSE_ACCEPT_HEADER,\n  SSE_STREAM_ID,\n  SUPPORTED_MCP_PROTOCOL_VERSIONS,\n  SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST,\n} from \"../constants.js\";\nimport type { McpServer } from \"../core.js\";\nimport { RpcError } from \"../errors.js\";\nimport type { SessionAdapter, SessionMeta } from \"../session-store.js\";\nimport { createSSEStream, type StreamWriter } from \"../sse-writer.js\";\nimport {\n  createJsonRpcError,\n  isGlobalNotification,\n  isJsonRpcNotification,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  JSON_RPC_ERROR_CODES,\n  type JsonRpcNotification,\n  type JsonRpcReq,\n  type JsonRpcRes,\n} from \"../types.js\";\nimport {\n  respondToInvalidJsonRpc,\n  respondToMissingProtocolHeader,\n  respondToMissingSessionId,\n  respondToProtocolMismatch,\n} from \"./http-responses.js\";\n\nfunction parseJsonRpc(body: string): unknown {\n  try {\n    const parsed = JSON.parse(body);\n    return parsed;\n  } catch (_error) {\n    throw new RpcError(JSON_RPC_ERROR_CODES.PARSE_ERROR, \"Invalid JSON\");\n  }\n}\n\nexport interface StreamableHttpTransportOptions {\n  sessionAdapter?: SessionAdapter;\n  clientRequestAdapter?: ClientRequestAdapter;\n  /** Allowed Origin headers for CORS validation  */\n  allowedOrigins?: string[];\n  /** Allowed Host headers for preventing Host header attacks */\n  allowedHosts?: string[];\n}\n\nexport class StreamableHttpTransport {\n  private server?: McpServer;\n  private sessionAdapter?: SessionAdapter;\n  private clientRequestAdapter?: ClientRequestAdapter;\n  private allowedOrigins?: string[];\n  private allowedHosts?: string[];\n  private sessionStreams = new Map<string, StreamWriter>(); // sessionId  GET stream writer\n  private requestStreams = new Map<string, StreamWriter>(); // \"sessionId:requestId\"  POST stream writer\n\n  constructor(options: StreamableHttpTransportOptions = {}) {\n    this.sessionAdapter = options.sessionAdapter;\n    this.clientRequestAdapter = options.clientRequestAdapter;\n    this.allowedOrigins = options.allowedOrigins;\n    this.allowedHosts = options.allowedHosts;\n  }\n\n  private getRequestWriter(\n    sessionId: string,\n    requestId: string | number,\n  ): StreamWriter | undefined {\n    return this.requestStreams.get(`${sessionId}:${requestId}`);\n  }\n\n  private getSessionWriter(sessionId: string): StreamWriter | undefined {\n    return this.sessionStreams.get(sessionId);\n  }\n\n  private cleanupSession(sessionId: string): void {\n    // End and remove session stream\n    const sessionWriter = this.sessionStreams.get(sessionId);\n    if (sessionWriter) {\n      sessionWriter.end();\n    }\n    this.sessionStreams.delete(sessionId);\n\n    // End and remove all request streams for this session\n    for (const [key, writer] of this.requestStreams) {\n      if (key.startsWith(`${sessionId}:`)) {\n        writer.end();\n        this.requestStreams.delete(key);\n      }\n    }\n  }\n\n  private async getClientCapabilities(sessionId: string | null): Promise<\n    | {\n        elicitation?: Record<string, never>;\n        roots?: Record<string, never>;\n        sampling?: Record<string, never>;\n        [key: string]: unknown;\n      }\n    | undefined\n  > {\n    if (!sessionId) {\n      return undefined;\n    }\n\n    // In stateless mode (no sessionAdapter), don't advertise elicitation capability\n    // since synthetic sessionId is never returned to client, causing elicitations to hang\n    if (!this.sessionAdapter) {\n      return {};\n    }\n\n    try {\n      const sessionData = await this.sessionAdapter.get(sessionId);\n      return sessionData?.meta?.clientCapabilities;\n    } catch {\n      return undefined;\n    }\n  }\n\n  private async getSessionProtocolVersion(\n    sessionId: string | null,\n  ): Promise<string | undefined> {\n    if (!sessionId || !this.sessionAdapter) {\n      return undefined;\n    }\n\n    try {\n      const sessionData = await this.sessionAdapter.get(sessionId);\n      return sessionData?.meta?.protocolVersion;\n    } catch {\n      // TODO: Invoke a logger here to warn that the session protocol version could not be fetched\n      return undefined;\n    }\n  }\n\n  private async sendClientRequest(\n    sessionId: string | undefined,\n    request: JsonRpcReq,\n    options?: { relatedRequestId?: string | number; timeout_ms?: number },\n  ): Promise<JsonRpcRes> {\n    if (!this.clientRequestAdapter) {\n      throw new Error(\"Client request adapter not configured\");\n    }\n\n    if (request.id === null || request.id === undefined) {\n      throw new Error(\"Client request must have a valid id\");\n    }\n\n    // Create pending promise for the response\n    const { promise } = this.clientRequestAdapter.createPending(\n      sessionId,\n      request.id,\n      { timeout_ms: options?.timeout_ms },\n    );\n\n    // Create JSON-RPC request message\n    const jsonRpcRequest = {\n      jsonrpc: JSON_RPC_VERSION,\n      id: request.id,\n      method: request.method,\n      params: request.params,\n    };\n\n    // Try to deliver via request stream first if relatedRequestId is provided\n    let delivered = false;\n    if (sessionId && options?.relatedRequestId !== undefined) {\n      const requestWriter = this.getRequestWriter(\n        sessionId,\n        options.relatedRequestId,\n      );\n      if (requestWriter) {\n        requestWriter.write(jsonRpcRequest);\n        delivered = true;\n      }\n    }\n\n    // Fallback to session stream if not delivered via request stream\n    if (!delivered && sessionId) {\n      const sessionWriter = this.getSessionWriter(sessionId);\n      if (sessionWriter) {\n        sessionWriter.write(jsonRpcRequest);\n        delivered = true;\n      }\n    }\n\n    if (!delivered) {\n      // Reject the pending request since we couldn't deliver it\n      this.clientRequestAdapter.rejectPending(\n        sessionId,\n        request.id, // We already checked this is not null/undefined above\n        new Error(\"No active streams to deliver client request\"),\n      );\n      throw new Error(\"No active streams to deliver client request\");\n    }\n\n    return promise as Promise<JsonRpcRes>;\n  }\n\n  bind(\n    server: McpServer,\n  ): (\n    request: Request,\n    options?: { authInfo?: AuthInfo },\n  ) => Promise<Response> {\n    this.server = server;\n\n    // Wire up client request sender if adapter is available\n    if (this.clientRequestAdapter) {\n      server._setClientRequestSender(this.sendClientRequest.bind(this));\n    }\n\n    server._setNotificationSender(async (sessionId, notification, options) => {\n      const jsonRpcNotification = {\n        jsonrpc: JSON_RPC_VERSION,\n        method: notification.method,\n        params: notification.params,\n      };\n\n      if (this.sessionAdapter) {\n        const relatedRequestId = options?.relatedRequestId;\n\n        if (sessionId) {\n          // Always persist to session store for resumability (even if delivered via request stream)\n          let eventId: string | undefined;\n          if (this.sessionAdapter) {\n            eventId = await this.sessionAdapter.appendEvent(\n              sessionId,\n              SSE_STREAM_ID,\n              jsonRpcNotification,\n            );\n          }\n\n          // Try request stream first if we have a relatedRequestId\n          if (relatedRequestId !== undefined) {\n            const requestWriter = this.getRequestWriter(\n              sessionId,\n              relatedRequestId,\n            );\n            if (requestWriter) {\n              requestWriter.write(jsonRpcNotification); // ephemeral delivery\n              return;\n            }\n          }\n\n          // Fallback to session stream\n          const sessionWriter = this.getSessionWriter(sessionId);\n          if (sessionWriter) {\n            sessionWriter.write(jsonRpcNotification, eventId);\n          }\n        }\n\n        // Handle global notifications (broadcast to all sessions)\n        const shouldBroadcastToAllSessions =\n          !sessionId || isGlobalNotification(notification.method);\n        if (shouldBroadcastToAllSessions) {\n          for (const [sid, writer] of this.sessionStreams) {\n            // Don't double-send to the originating session\n            if (sid !== sessionId) {\n              writer.write(jsonRpcNotification);\n            }\n          }\n        }\n      } else {\n        // Stateless mode: deliver to request streams using synthetic session ID\n        if (options?.relatedRequestId && sessionId) {\n          const requestWriter = this.getRequestWriter(\n            sessionId,\n            options.relatedRequestId,\n          );\n          if (requestWriter) {\n            requestWriter.write(jsonRpcNotification);\n          }\n        }\n\n        // Handle global notifications in stateless mode (broadcast to all request streams)\n        const shouldBroadcastToAllRequests =\n          !sessionId || isGlobalNotification(notification.method);\n        if (shouldBroadcastToAllRequests) {\n          for (const [requestKey, writer] of this.requestStreams) {\n            // Don't double-send to the originating request\n            if (!sessionId || !requestKey.startsWith(`${sessionId}:`)) {\n              writer.write(jsonRpcNotification);\n            }\n          }\n        }\n      }\n    });\n\n    return this.handleRequest.bind(this);\n  }\n\n  private async handleRequest(\n    request: Request,\n    options?: { authInfo?: AuthInfo },\n  ): Promise<Response> {\n    if (!this.server) {\n      throw new Error(\"Transport not bound to a server\");\n    }\n\n    if (this.allowedHosts) {\n      const host = request.headers.get(\"Host\");\n      if (host && !this.allowedHosts.includes(host)) {\n        return new Response(\"Forbidden\", { status: 403 });\n      }\n    }\n\n    if (this.allowedOrigins) {\n      const origin = request.headers.get(\"Origin\");\n      if (origin && !this.allowedOrigins.includes(origin)) {\n        return new Response(\"Forbidden\", { status: 403 });\n      }\n    }\n\n    switch (request.method) {\n      case \"POST\":\n        return this.handlePost(request, { authInfo: options?.authInfo });\n      case \"GET\":\n        return this.handleGet(request);\n      case \"DELETE\":\n        return this.handleDelete(request);\n      default: {\n        const errorResponse = createJsonRpcError(\n          null,\n          new RpcError(\n            JSON_RPC_ERROR_CODES.INVALID_REQUEST,\n            \"Method not supported\",\n          ).toJson(),\n        );\n        return new Response(JSON.stringify(errorResponse), {\n          status: 405,\n          headers: {\n            Allow: \"POST, GET, DELETE\",\n          },\n        });\n      }\n    }\n  }\n\n  /**\n   * Validates the MCP-Protocol-Version header based on session version\n   * Returns null if valid, or an error Response if invalid\n   */\n  private validateProtocolHeader(\n    sessionVersion: string | undefined,\n    protocolHeader: string | null,\n    jsonRpcMessage: JsonRpcReq | JsonRpcNotification,\n    isNotification: boolean,\n  ): Response | null {\n    const responseId = isNotification\n      ? null\n      : (jsonRpcMessage as JsonRpcReq).id;\n\n    // For 2025-06-18: header is REQUIRED\n    if (sessionVersion === SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_06_18) {\n      if (!protocolHeader) {\n        return respondToMissingProtocolHeader(responseId);\n      }\n      if (protocolHeader !== sessionVersion) {\n        return respondToProtocolMismatch(\n          responseId,\n          protocolHeader,\n          sessionVersion,\n        );\n      }\n      return null;\n    }\n\n    // For 2025-03-26: header is optional, but if present must match\n    if (sessionVersion === SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_03_26) {\n      if (protocolHeader && protocolHeader !== sessionVersion) {\n        return respondToProtocolMismatch(\n          responseId,\n          protocolHeader,\n          sessionVersion,\n        );\n      }\n      return null;\n    }\n\n    // No session: validate header if present\n    if (\n      protocolHeader &&\n      !SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST.includes(\n        protocolHeader as (typeof SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST)[number],\n      )\n    ) {\n      return respondToProtocolMismatch(\n        responseId,\n        protocolHeader,\n        SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST,\n      );\n    }\n\n    return null;\n  }\n\n  private async handlePost(\n    request: Request,\n    options?: { authInfo?: AuthInfo },\n  ): Promise<Response> {\n    try {\n      const sessionId = request.headers.get(MCP_SESSION_ID_HEADER);\n      const body = await request.text();\n      const jsonRpcMessage = parseJsonRpc(body);\n\n      // Check for batch requests (array of requests)\n      if (Array.isArray(jsonRpcMessage)) {\n        // Batching removed in 2025-06-18, only supported in 2025-03-26\n        let sessionVersion: string | undefined;\n        if (this.sessionAdapter && sessionId) {\n          const session = await this.sessionAdapter.get(sessionId);\n          sessionVersion = session?.meta?.protocolVersion;\n        }\n\n        if (sessionVersion === SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_03_26) {\n          // Process batch for 2025-03-26\n          return this.handleBatchRequest(jsonRpcMessage, sessionId, options);\n        }\n\n        // Reject batching for 2025-06-18 or unknown versions\n        const errorResponse = createJsonRpcError(\n          null,\n          new RpcError(\n            JSON_RPC_ERROR_CODES.INVALID_REQUEST,\n            \"Batch requests are not supported in protocol version 2025-06-18\",\n          ).toJson(),\n        );\n        return new Response(JSON.stringify(errorResponse), {\n          status: 400,\n          headers: { \"Content-Type\": \"application/json\" },\n        });\n      }\n\n      // Check if it's a JSON-RPC response first\n      if (isJsonRpcResponse(jsonRpcMessage)) {\n        if (this.sessionAdapter && !sessionId) {\n          return respondToMissingSessionId();\n        }\n\n        // Handle client response by resolving pending request\n        if (\n          this.clientRequestAdapter &&\n          jsonRpcMessage.id !== null &&\n          jsonRpcMessage.id !== undefined\n        ) {\n          this.clientRequestAdapter.resolvePending(\n            sessionId || undefined,\n            jsonRpcMessage.id,\n            jsonRpcMessage,\n          );\n        }\n\n        return new Response(null, { status: 202 });\n      }\n\n      if (\n        !isJsonRpcNotification(jsonRpcMessage) &&\n        !isJsonRpcRequest(jsonRpcMessage)\n      ) {\n        return respondToInvalidJsonRpc();\n      }\n\n      const isNotification = isJsonRpcNotification(jsonRpcMessage);\n      const isInitializeRequest = jsonRpcMessage.method === \"initialize\";\n      const acceptHeader = request.headers.get(\"Accept\");\n      const protocolHeader = request.headers.get(MCP_PROTOCOL_HEADER);\n\n      // Protocol header enforcement based on session version\n      if (!isInitializeRequest) {\n        let sessionVersion: string | undefined;\n        if (this.sessionAdapter && sessionId) {\n          const session = await this.sessionAdapter.get(sessionId);\n          sessionVersion = session?.meta?.protocolVersion;\n        }\n\n        const validationError = this.validateProtocolHeader(\n          sessionVersion,\n          protocolHeader,\n          jsonRpcMessage,\n          isNotification,\n        );\n        if (validationError) {\n          return validationError;\n        }\n      }\n\n      // Check for missing session ID (except for initialize requests)\n      if (this.sessionAdapter && !sessionId && !isInitializeRequest) {\n        return respondToMissingSessionId();\n      }\n\n      if (\n        !isInitializeRequest &&\n        !isNotification &&\n        acceptHeader?.includes(SSE_ACCEPT_HEADER)\n      ) {\n        return this.handlePostSse({\n          request,\n          jsonRpcRequest: jsonRpcMessage,\n          sessionId,\n          isNotification,\n          authInfo: options?.authInfo,\n        });\n      }\n\n      const response = await this.server?._dispatch(jsonRpcMessage, {\n        sessionId: sessionId || undefined,\n        sessionProtocolVersion: await this.getSessionProtocolVersion(sessionId),\n        authInfo: options?.authInfo,\n        clientCapabilities: await this.getClientCapabilities(sessionId),\n      });\n\n      if (isInitializeRequest && response) {\n        if (this.sessionAdapter) {\n          const sessionId = this.sessionAdapter.generateSessionId();\n\n          // Extract capabilities from initialize params\n          const initParams = (jsonRpcMessage as JsonRpcReq).params as {\n            clientInfo?: unknown;\n            capabilities?: {\n              elicitation?: Record<string, never>;\n              roots?: Record<string, never>;\n              sampling?: Record<string, never>;\n              [key: string]: unknown;\n            };\n          };\n\n          // Use the negotiated protocol version from the response (echoed by core)\n          const negotiatedVersion =\n            (response.result as { protocolVersion?: string })\n              ?.protocolVersion || SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_06_18;\n\n          const sessionMeta: SessionMeta = {\n            protocolVersion: negotiatedVersion,\n            clientInfo: initParams.clientInfo,\n            clientCapabilities: initParams.capabilities, // Store capabilities\n          };\n          await this.sessionAdapter.create(sessionId, sessionMeta);\n          return new Response(JSON.stringify(response), {\n            status: 200,\n            headers: {\n              \"Content-Type\": \"application/json\",\n              [MCP_SESSION_ID_HEADER]: sessionId,\n            },\n          });\n        }\n        return new Response(JSON.stringify(response), {\n          status: 200,\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n        });\n      }\n\n      if (response === null) {\n        return new Response(null, { status: 202 });\n      } else {\n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n        };\n\n        if (this.sessionAdapter && !isInitializeRequest) {\n          const sessionId = request.headers.get(MCP_SESSION_ID_HEADER);\n          if (sessionId) {\n            headers[MCP_SESSION_ID_HEADER] = sessionId;\n          }\n        }\n\n        return new Response(JSON.stringify(response), {\n          status: 200,\n          headers,\n        });\n      }\n    } catch (error) {\n      const errorResponse = createJsonRpcError(\n        null,\n        new RpcError(\n          JSON_RPC_ERROR_CODES.PARSE_ERROR,\n          \"Parse error\",\n          error instanceof Error ? error.message : \"Unknown parsing error\",\n        ).toJson(),\n      );\n\n      return new Response(JSON.stringify(errorResponse), {\n        status: 400,\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      });\n    }\n  }\n\n  private async handleBatchRequest(\n    batch: unknown[],\n    sessionId: string | null,\n    options?: { authInfo?: AuthInfo },\n  ): Promise<Response> {\n    const responses: JsonRpcRes[] = [];\n\n    const sessionProtocolVersion =\n      await this.getSessionProtocolVersion(sessionId);\n    const clientCapabilities = await this.getClientCapabilities(sessionId);\n\n    for (const message of batch) {\n      if (!isJsonRpcRequest(message) && !isJsonRpcNotification(message)) {\n        // Invalid message in batch\n        responses.push(\n          createJsonRpcError(\n            null,\n            new RpcError(\n              JSON_RPC_ERROR_CODES.INVALID_REQUEST,\n              \"Invalid JSON-RPC 2.0 message in batch\",\n            ).toJson(),\n          ),\n        );\n        continue;\n      }\n\n      try {\n        const response = await this.server?._dispatch(message, {\n          sessionId: sessionId || undefined,\n          sessionProtocolVersion,\n          authInfo: options?.authInfo,\n          clientCapabilities,\n        });\n\n        if (response !== null && response !== undefined) {\n          responses.push(response);\n        }\n        // Notifications don't get responses\n      } catch (error) {\n        const errorResponse = createJsonRpcError(\n          (message as JsonRpcReq).id || null,\n          new RpcError(\n            JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n            \"Internal error processing batch item\",\n            error instanceof Error ? error.message : \"Unknown error\",\n          ).toJson(),\n        );\n        responses.push(errorResponse);\n      }\n    }\n\n    return new Response(JSON.stringify(responses), {\n      status: 200,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...(this.sessionAdapter && sessionId\n          ? { [MCP_SESSION_ID_HEADER]: sessionId }\n          : {}),\n      },\n    });\n  }\n\n  private async handlePostSse(args: {\n    request: Request;\n    jsonRpcRequest: unknown;\n    sessionId: string | null;\n    isNotification: boolean;\n    authInfo?: AuthInfo;\n  }): Promise<Response> {\n    const { jsonRpcRequest, sessionId, isNotification, authInfo } = args;\n\n    if (isNotification) {\n      return new Response(\n        \"Bad Request: POST SSE requires a request with 'id' (notifications not supported)\",\n        {\n          status: 400,\n        },\n      );\n    }\n\n    const requestId = (jsonRpcRequest as JsonRpcReq).id;\n    if (requestId === null || requestId === undefined) {\n      return new Response(\n        \"Bad Request: POST SSE requires a request with 'id'\",\n        {\n          status: 400,\n        },\n      );\n    }\n\n    // Generate synthetic session ID for stateless mode to enable notification routing\n    const effectiveSessionId = sessionId || crypto.randomUUID();\n\n    const { stream, writer } = createSSEStream({\n      onClose: () => {\n        this.requestStreams.delete(`${effectiveSessionId}:${requestId}`);\n      },\n    });\n\n    // Register this request stream using effective session ID\n    this.requestStreams.set(`${effectiveSessionId}:${requestId}`, writer);\n\n    // Dispatch; route progress/responses to this writer (ephemeral; do not persist)\n    Promise.resolve(\n      this.server?._dispatch(jsonRpcRequest as JsonRpcReq, {\n        sessionId: effectiveSessionId,\n        sessionProtocolVersion:\n          await this.getSessionProtocolVersion(effectiveSessionId),\n        authInfo,\n        clientCapabilities:\n          await this.getClientCapabilities(effectiveSessionId),\n      }),\n    )\n      .then(async (rpcResponse) => {\n        if (rpcResponse !== null) {\n          writer.write(rpcResponse); // omit id for per-request streams\n        }\n      })\n      .catch((err) => {\n        try {\n          const responseId = (jsonRpcRequest as JsonRpcReq).id;\n          if (responseId !== null && responseId !== undefined) {\n            const errorResponse = createJsonRpcError(\n              responseId,\n              new RpcError(\n                JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n                \"Internal error\",\n                err instanceof Error ? { message: err.message } : err,\n              ).toJson(),\n            );\n            writer.write(errorResponse);\n          }\n        } catch (_) {}\n      })\n      .finally(() => {\n        writer.end();\n        // Ensure cleanup in case onClose wasn't triggered\n        this.requestStreams.delete(`${effectiveSessionId}:${requestId}`);\n      });\n\n    const headers: Record<string, string> = {\n      \"Content-Type\": SSE_ACCEPT_HEADER,\n      Connection: \"keep-alive\",\n    };\n\n    // Add session id to header if sessions are supported\n    if (this.sessionAdapter && sessionId) {\n      headers[MCP_SESSION_ID_HEADER] = sessionId;\n    }\n\n    return new Response(stream as ReadableStream, {\n      status: 200,\n      headers,\n    });\n  }\n\n  private async handleGet(request: Request): Promise<Response> {\n    const accept = request.headers.get(\"Accept\");\n    if (!accept || !accept.includes(SSE_ACCEPT_HEADER)) {\n      return new Response(\n        \"Bad Request: Accept header must be text/event-stream\",\n        {\n          status: 400,\n        },\n      );\n    }\n\n    const protocolHeader = request.headers.get(MCP_PROTOCOL_HEADER);\n    if (\n      protocolHeader &&\n      protocolHeader !== SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_06_18\n    ) {\n      return new Response(\"Bad Request: Protocol version mismatch\", {\n        status: 400,\n      });\n    }\n\n    if (!this.sessionAdapter) {\n      // Stateless mode does not provide a standalone GET stream\n      return new Response(\"Method Not Allowed\", { status: 405 });\n    }\n\n    const sessionId = request.headers.get(MCP_SESSION_ID_HEADER);\n    if (!sessionId || !(await this.sessionAdapter?.has(sessionId))) {\n      return new Response(\"Bad Request: Invalid or missing session ID\", {\n        status: 400,\n      });\n    }\n\n    if (this.sessionStreams.has(sessionId)) {\n      return new Response(\"Conflict: Stream already exists for session\", {\n        status: 409,\n      });\n    }\n\n    const { stream, writer } = createSSEStream({\n      onClose: () => this.sessionStreams.delete(sessionId),\n    });\n\n    // Register the session stream\n    this.sessionStreams.set(sessionId, writer);\n\n    // Optional resume (store expects suffixed Last-Event-ID: \"<n>#<streamId>\")\n    const lastEventId = request.headers.get(MCP_LAST_EVENT_ID_HEADER);\n    let attemptedReplay = false;\n    if (lastEventId) {\n      attemptedReplay = true;\n      try {\n        await this.sessionAdapter.replay(sessionId, lastEventId, (eid, msg) => {\n          writer.write(msg, eid);\n        });\n      } catch (_error) {\n        writer.end();\n        return new Response(\"Internal Server Error: Replay failed\", {\n          status: 500,\n        });\n      }\n    }\n\n    // Send a JSON-RPC ping to establish the SSE connection if we didn't attempt replay\n    // This is needed because SSE clients expect initial data to confirm the stream is working.\n    // If we attempted replay (even if it returned 0 events), we don't send ping because the\n    // client explicitly requested to resume from a specific point. If no replay was requested,\n    // we send a ping (not awaiting pong) just to establish the connection - this is not\n    // fully spec-compliant but ensures compatibility with MCP inspector (which expects\n    // valid JSON-RPC format) while maintaining SSE stream functionality.\n    if (!attemptedReplay) {\n      const pingNotification = {\n        jsonrpc: JSON_RPC_VERSION,\n        method: \"ping\",\n        params: {},\n      };\n      writer.write(pingNotification);\n    }\n\n    return new Response(stream as ReadableStream, {\n      status: 200,\n      headers: {\n        \"Content-Type\": SSE_ACCEPT_HEADER,\n        Connection: \"keep-alive\",\n        [MCP_SESSION_ID_HEADER]: sessionId,\n      },\n    });\n  }\n\n  private async handleDelete(request: Request): Promise<Response> {\n    const sessionId = request.headers.get(MCP_SESSION_ID_HEADER);\n    if (!this.sessionAdapter) {\n      return new Response(\"Method Not Allowed\", { status: 405 });\n    }\n\n    if (!sessionId) {\n      return new Response(\"Bad Request: Missing session ID\", {\n        status: 400,\n      });\n    }\n\n    this.cleanupSession(sessionId);\n\n    await this.sessionAdapter.delete(sessionId);\n\n    return new Response(null, { status: 200 });\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "C36562CABF59002464756E2164756E21",
  "names": []
}