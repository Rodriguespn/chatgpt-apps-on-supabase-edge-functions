// src/client-request-adapter.ts
function makeKey(sessionId, requestId) {
  return `${sessionId ?? ""}:${String(requestId)}`;
}

class InMemoryClientRequestAdapter {
  pending = new Map;
  defaultTimeoutMs;
  constructor(options) {
    this.defaultTimeoutMs = options?.defaultTimeoutMs;
  }
  createPending(sessionId, requestId, options) {
    const key = makeKey(sessionId, requestId);
    const existingEntry = this.pending.get(key);
    if (existingEntry) {
      if (existingEntry.timer) {
        clearTimeout(existingEntry.timer);
      }
      existingEntry.reject(new Error("Request replaced by new request with same key"));
      this.pending.delete(key);
    }
    let resolve;
    let reject;
    const promise = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });
    const entry = { resolve, reject };
    const timeoutMs = options?.timeout_ms ?? this.defaultTimeoutMs;
    if (timeoutMs && timeoutMs > 0) {
      entry.timer = setTimeout(() => {
        this.pending.delete(key);
        reject(new Error(`Client request ${requestId} timed out after ${timeoutMs}ms`));
      }, timeoutMs);
    }
    this.pending.set(key, entry);
    return { promise };
  }
  resolvePending(sessionId, requestId, response) {
    const key = makeKey(sessionId, requestId);
    const entry = this.pending.get(key);
    if (!entry)
      return false;
    if (entry.timer)
      clearTimeout(entry.timer);
    this.pending.delete(key);
    entry.resolve(response);
    return true;
  }
  rejectPending(sessionId, requestId, reason) {
    const key = makeKey(sessionId, requestId);
    const entry = this.pending.get(key);
    if (!entry)
      return false;
    if (entry.timer)
      clearTimeout(entry.timer);
    this.pending.delete(key);
    entry.reject(reason);
    return true;
  }
}
// src/constants.ts
var JSON_RPC_VERSION = "2.0";
var SUPPORTED_MCP_PROTOCOL_VERSIONS = {
  V2025_03_26: "2025-03-26",
  V2025_06_18: "2025-06-18"
};
var SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST = Object.values(SUPPORTED_MCP_PROTOCOL_VERSIONS);
var MCP_PROTOCOL_HEADER = "MCP-Protocol-Version";
var MCP_SESSION_ID_HEADER = "MCP-Session-Id";
var MCP_LAST_EVENT_ID_HEADER = "Last-Event-ID";
var SSE_ACCEPT_HEADER = "text/event-stream";
var METHODS = {
  INITIALIZE: "initialize",
  PING: "ping",
  TOOLS: {
    LIST: "tools/list",
    CALL: "tools/call"
  },
  PROMPTS: {
    LIST: "prompts/list",
    GET: "prompts/get"
  },
  RESOURCES: {
    LIST: "resources/list",
    TEMPLATES_LIST: "resources/templates/list",
    READ: "resources/read",
    SUBSCRIBE: "resources/subscribe",
    UNSUBSCRIBE: "resources/unsubscribe"
  },
  COMPLETION: {
    COMPLETE: "completion/complete"
  },
  ELICITATION: {
    CREATE: "elicitation/create"
  },
  SAMPLING: {
    CREATE: "sampling/createMessage"
  },
  NOTIFICATIONS: {
    CANCELLED: "notifications/cancelled",
    INITIALIZED: "notifications/initialized",
    PROGRESS: "notifications/progress",
    ROOTS: {
      LIST_CHANGED: "notifications/roots/list_changed"
    },
    TOOLS: {
      LIST_CHANGED: "notifications/tools/list_changed"
    },
    PROMPTS: {
      LIST_CHANGED: "notifications/prompts/list_changed"
    },
    RESOURCES: {
      LIST_CHANGED: "notifications/resources/list_changed"
    }
  },
  LOGGING: {
    SET_LEVEL: "logging/setLevel"
  }
};
var GLOBAL_NOTIFICATIONS = [
  METHODS.NOTIFICATIONS.TOOLS.LIST_CHANGED,
  METHODS.NOTIFICATIONS.PROMPTS.LIST_CHANGED,
  METHODS.NOTIFICATIONS.RESOURCES.LIST_CHANGED
];
var SSE_STREAM_ID = "_GET_stream";
// src/errors.ts
class RpcError extends Error {
  code;
  data;
  cause;
  constructor(code, message, data, cause) {
    super(message);
    this.name = "RpcError";
    this.code = code;
    this.data = data;
    this.cause = cause;
    Object.setPrototypeOf(this, new.target.prototype);
  }
  toJson() {
    return {
      code: this.code,
      message: this.message,
      data: this.data
    };
  }
}

// src/utils.ts
function isObject(value) {
  return typeof value === "object" && value !== null;
}
function objectWithKey(value, key) {
  return isObject(value) && key in value;
}
function objectWithDefinedKey(value, key) {
  if (!isObject(value)) {
    return false;
  }
  const candidate = value;
  if (!(key in candidate)) {
    return false;
  }
  return candidate[key] !== undefined;
}
function objectWithKeyAndValue(value, key, expectedValue) {
  return objectWithKey(value, key) && value[key] === expectedValue;
}
function objectWithKeyOfType(value, key, typeGuard) {
  return objectWithKey(value, key) && typeGuard(value[key]);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function errorToResponse(err, requestId) {
  if (requestId === undefined) {
    return null;
  }
  if (err instanceof RpcError) {
    return createJsonRpcError(requestId, err.toJson());
  }
  const errorData = err instanceof Error ? { message: err.message, stack: err.stack } : err;
  return createJsonRpcError(requestId, new RpcError(JSON_RPC_ERROR_CODES.INTERNAL_ERROR, "Internal error", errorData).toJson());
}

// src/types.ts
var JSON_RPC_ERROR_CODES = {
  PARSE_ERROR: -32700,
  INVALID_REQUEST: -32600,
  METHOD_NOT_FOUND: -32601,
  INVALID_PARAMS: -32602,
  INTERNAL_ERROR: -32603
};
function isJsonRpcNotification(obj) {
  if (!isObject(obj)) {
    return false;
  }
  const candidate = obj;
  if (candidate.jsonrpc !== "2.0") {
    return false;
  }
  if (!isString(candidate.method)) {
    return false;
  }
  if ("id" in candidate) {
    return false;
  }
  return true;
}
function isJsonRpcRequest(obj) {
  if (!isObject(obj)) {
    return false;
  }
  const candidate = obj;
  if (candidate.jsonrpc !== "2.0") {
    return false;
  }
  if (!isString(candidate.method)) {
    return false;
  }
  if (!("id" in candidate)) {
    return false;
  }
  const id = candidate.id;
  if (!isString(id) && !isNumber(id) && id !== null) {
    return false;
  }
  return true;
}
function isJsonRpcResponse(obj) {
  if (!isObject(obj)) {
    return false;
  }
  const candidate = obj;
  if (candidate.jsonrpc !== "2.0") {
    return false;
  }
  if (!("id" in candidate)) {
    return false;
  }
  const id = candidate.id;
  if (!isString(id) && !isNumber(id) && id !== null) {
    return false;
  }
  if (!("result" in candidate) && !("error" in candidate)) {
    return false;
  }
  return true;
}
function createJsonRpcResponse(id, result) {
  return {
    jsonrpc: JSON_RPC_VERSION,
    id,
    result
  };
}
function createJsonRpcError(id, error) {
  return {
    jsonrpc: JSON_RPC_VERSION,
    id,
    error
  };
}
function isInitializeParams(obj) {
  if (!isObject(obj)) {
    return false;
  }
  const candidate = obj;
  if (!objectWithKeyOfType(candidate, "protocolVersion", isString)) {
    return false;
  }
  if (objectWithDefinedKey(candidate, "capabilities") && !objectWithKeyOfType(candidate, "capabilities", isObject)) {
    return false;
  }
  if (objectWithDefinedKey(candidate, "clientInfo")) {
    if (!objectWithKeyOfType(candidate, "clientInfo", isObject)) {
      return false;
    }
    const clientInfoObj = candidate.clientInfo;
    if (!isClientInfo(clientInfoObj)) {
      return false;
    }
  }
  return true;
}
function isClientInfo(obj) {
  if (!objectWithKeyOfType(obj, "name", isString)) {
    return false;
  }
  if (!objectWithKeyOfType(obj, "version", isString)) {
    return false;
  }
  return true;
}
function isStandardSchema(value) {
  return value !== null && (typeof value === "object" || typeof value === "function") && "~standard" in value && typeof value["~standard"] === "object" && value["~standard"].version === 1;
}
function isGlobalNotification(notificationMethod) {
  for (const globalNotification of GLOBAL_NOTIFICATIONS) {
    if (notificationMethod === globalNotification) {
      return true;
    }
  }
  return false;
}
function isSamplingResult(o) {
  return objectWithKeyOfType(o, "content", isSamplingContent);
}
function isSamplingContent(o) {
  return isSamplingTextContent(o) || isSamplingImageContent(o) || isSamplingAudioContent(o);
}
function isSamplingTextContent(o) {
  return objectWithKeyAndValue(o, "type", "text") && objectWithKeyOfType(o, "text", isString);
}
function isSamplingImageContent(o) {
  return objectWithKeyAndValue(o, "type", "image") && objectWithKeyOfType(o, "data", isString);
}
function isSamplingAudioContent(o) {
  return objectWithKeyAndValue(o, "type", "audio") && objectWithKeyOfType(o, "data", isString);
}

// src/validation.ts
function resolveSchema(schema, schemaAdapter) {
  if (!schema)
    return { resolvedSchema: { type: "object" } };
  if (isStandardSchema(schema)) {
    if (!schemaAdapter) {
      const vendor = schema["~standard"].vendor;
      throw new Error(`Cannot use Standard Schema (vendor: "${vendor}") without a schema adapter. ` + `Configure a schema adapter when creating McpServer.`);
    }
    const jsonSchema = schemaAdapter(schema);
    return { resolvedSchema: jsonSchema, validator: schema };
  }
  return { resolvedSchema: schema };
}
function createValidationFunction(validator, input) {
  if (isStandardSchema(validator)) {
    const result = validator["~standard"].validate(input);
    if (result instanceof Promise) {
      throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, "Async validation not supported in this context");
    }
    if ("issues" in result && result.issues?.length) {
      const messages = result.issues.map((i) => i.message).join(", ");
      throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, `Validation failed: ${messages}`);
    }
    return result.value;
  }
  if (validator && typeof validator === "object" && "validate" in validator) {
    const validatorObj = validator;
    const result = validatorObj.validate(input);
    if (result?.ok && result.data !== undefined) {
      return result.data;
    }
    throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, "Validation failed");
  }
  throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, "Invalid validator");
}
function extractArgumentsFromSchema(schema) {
  if (!schema || typeof schema !== "object") {
    return [];
  }
  const schemaObj = schema;
  if (schemaObj.type === "object" && schemaObj.properties) {
    const properties = schemaObj.properties;
    const required = schemaObj.required || [];
    return Object.entries(properties).map(([name, propSchema]) => {
      const prop = propSchema;
      return {
        name,
        description: prop.description,
        required: required.includes(name)
      };
    });
  }
  return [];
}
function toElicitationRequestedSchema(schema, strict = false) {
  if (isStandardSchema(schema)) {
    throw new Error("Standard Schema inputs must be converted via resolveSchema first");
  }
  if (!schema || typeof schema !== "object") {
    if (strict) {
      throw new Error("Schema must be an object");
    }
    return { type: "object", properties: {} };
  }
  const schemaObj = schema;
  if (schemaObj.type !== "object") {
    if (strict) {
      throw new Error("Root schema must be of type 'object'");
    }
    return { type: "object", properties: {} };
  }
  if (!schemaObj.properties || typeof schemaObj.properties !== "object") {
    if (strict) {
      throw new Error("Object schema must have properties");
    }
    return { type: "object", properties: {} };
  }
  const properties = schemaObj.properties;
  const requiredArray = Array.isArray(schemaObj.required) ? schemaObj.required : [];
  const elicitationProperties = {};
  const validRequired = [];
  for (const [propName, propSchema] of Object.entries(properties)) {
    const projectedProp = projectPropertyToElicitation(propSchema, strict);
    if (projectedProp !== null) {
      elicitationProperties[propName] = projectedProp;
      if (requiredArray.includes(propName)) {
        validRequired.push(propName);
      }
    }
  }
  const result = {
    type: "object",
    properties: elicitationProperties
  };
  if (validRequired.length > 0) {
    result.required = validRequired;
  }
  return result;
}
function projectPropertyToElicitation(propSchema, strict) {
  if (!propSchema || typeof propSchema !== "object") {
    if (strict) {
      throw new Error("Property schema must be an object");
    }
    return null;
  }
  const prop = propSchema;
  const propType = prop.type;
  if (propType === "string" || propType === "number" || propType === "integer" || propType === "boolean") {
    const result = { type: propType };
    if (typeof prop.description === "string") {
      result.description = prop.description;
    }
    if (prop.default !== undefined) {
      result.default = prop.default;
    }
    if (propType === "string") {
      if (typeof prop.minLength === "number") {
        result.minLength = prop.minLength;
      }
      if (typeof prop.maxLength === "number") {
        result.maxLength = prop.maxLength;
      }
      if (typeof prop.format === "string") {
        const supportedFormats = ["email", "uri", "date", "date-time"];
        if (supportedFormats.includes(prop.format)) {
          result.format = prop.format;
        } else if (strict) {
          throw new Error(`Unsupported string format: ${prop.format}`);
        }
      }
      if (Array.isArray(prop.enum)) {
        const enumValues = prop.enum;
        const enumNames = Array.isArray(prop.enumNames) ? prop.enumNames : undefined;
        if (enumValues.every((val) => typeof val === "string")) {
          result.enum = enumValues;
          if (enumNames && enumNames.length === enumValues.length) {
            result.enumNames = enumNames;
          }
        } else if (strict) {
          throw new Error("Enum values must be strings for elicitation");
        }
      }
    }
    if (propType === "number" || propType === "integer") {
      if (typeof prop.minimum === "number") {
        result.minimum = prop.minimum;
      }
      if (typeof prop.maximum === "number") {
        result.maximum = prop.maximum;
      }
    }
    return result;
  }
  if (strict) {
    throw new Error(`Unsupported property type: ${propType}`);
  }
  return null;
}

// src/context.ts
function getProgressToken(message) {
  if (isObject(message.params)) {
    const params = message.params;
    const meta = params._meta;
    if (objectWithKey(meta, "progressToken")) {
      return meta.progressToken;
    }
  }
  return;
}
function createContext(message, requestId, options = {}) {
  const progressToken = options.progressToken !== undefined ? options.progressToken : getProgressToken(message);
  const context = {
    request: message,
    authInfo: options.authInfo,
    requestId,
    response: null,
    env: {},
    state: {},
    progressToken,
    validate: (validator, input) => createValidationFunction(validator, input),
    client: {
      supports: (feature) => {
        if (options.clientCapabilities) {
          return feature in options.clientCapabilities;
        }
        return false;
      }
    },
    elicit: async (params, elicitOptions) => {
      if (!context.client.supports("elicitation")) {
        throw new RpcError(JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND, "Elicitation not supported by client");
      }
      const { resolvedSchema } = resolveSchema(params.schema, options.schemaAdapter);
      const requestedSchema = toElicitationRequestedSchema(resolvedSchema, elicitOptions?.strict);
      const elicitRequest = {
        jsonrpc: "2.0",
        id: Math.random().toString(36).substring(7),
        method: METHODS.ELICITATION.CREATE,
        params: {
          message: params.message,
          requestedSchema
        }
      };
      if (!options.clientRequestSender) {
        throw new RpcError(JSON_RPC_ERROR_CODES.INTERNAL_ERROR, "Client request sender not configured");
      }
      const response = await options.clientRequestSender(context.session?.id, elicitRequest, {
        relatedRequestId: requestId,
        timeout_ms: elicitOptions?.timeout_ms
      });
      if (response.error) {
        throw new RpcError(response.error.code, response.error.message, response.error.data);
      }
      return response.result;
    },
    sample: async (params, sampleOptions) => {
      if (!context.client.supports("sampling")) {
        throw new RpcError(JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND, "Sampling not supported by client");
      }
      const samplingRequest = {
        jsonrpc: "2.0",
        id: Math.random().toString(36).substring(7),
        method: METHODS.SAMPLING.CREATE,
        params: {
          messages: [
            {
              role: "user",
              content: {
                type: "text",
                text: params.prompt
              }
            }
          ],
          modelPreferences: params.modelPreferences,
          systemPrompt: params.systemPrompt,
          maxTokens: params.maxTokens
        }
      };
      if (!options.clientRequestSender) {
        throw new RpcError(JSON_RPC_ERROR_CODES.INTERNAL_ERROR, "Client request sender not configured");
      }
      const response = await options.clientRequestSender(context.session?.id, samplingRequest, {
        relatedRequestId: requestId,
        timeout_ms: sampleOptions?.timeout_ms
      });
      if (response.error) {
        throw new RpcError(response.error.code, response.error.message, response.error.data);
      }
      if (!isSamplingResult(response.result)) {
        console.error("Unexpected sampling response format from client", JSON.stringify(response.result, null, 2));
        throw new RpcError(-32602, "Unexpected sampling response format from client");
      }
      return response.result;
    }
  };
  if (progressToken && options.progressSender) {
    context.progress = async (update) => {
      await options.progressSender?.(update);
    };
  }
  if (options.sessionId) {
    context.session = {
      id: options.sessionId,
      protocolVersion: options.sessionProtocolVersion || SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_03_26
    };
  }
  return context;
}

// src/uri-template.ts
function compileUriTemplate(template) {
  const isStatic = !template.includes("{");
  if (isStatic) {
    return {
      match: (uri) => uri === template ? {} : null,
      type: "resource"
    };
  }
  const queryMatch = template.match(/\{\?([^}]+)\}/);
  const queryParams = queryMatch?.[1] ? queryMatch[1].split(",").map((p) => p.trim()) : [];
  const pathTemplate = template.replace(/\{\?[^}]+\}/, "");
  let escapedTemplate = pathTemplate.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  escapedTemplate = escapedTemplate.replace(/\\{([^}*]+)\\*\\}/g, "(?<$1>.*)").replace(/\\{([^}]+)\\}/g, "(?<$1>[^/?]+)");
  const regex = new RegExp(`^${escapedTemplate}$`);
  return {
    match: (uri) => {
      try {
        const [pathPart] = uri.split("?");
        const matchTarget = queryParams.length > 0 ? pathPart ?? uri : uri;
        const pathMatch = matchTarget.match(regex);
        if (!pathMatch)
          return null;
        const vars = { ...pathMatch.groups };
        if (queryParams.length > 0) {
          try {
            const url = new URL(uri);
            for (const param of queryParams) {
              const value = url.searchParams.get(param);
              if (value !== null) {
                vars[param] = value;
              }
            }
          } catch {}
        }
        return vars;
      } catch {
        return null;
      }
    },
    type: "resource_template"
  };
}

// src/core.ts
function isSupportedVersion(version) {
  return SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST.includes(version);
}
async function runMiddlewares(middlewares, ctx, tail) {
  const dispatch = async (i) => {
    if (i < middlewares.length) {
      const middleware = middlewares[i];
      if (middleware) {
        await middleware(ctx, () => dispatch(i + 1));
      } else {
        await dispatch(i + 1);
      }
    } else {
      await tail();
    }
  };
  await dispatch(0);
}

class McpServer {
  methods = {};
  initialized = false;
  serverInfo;
  middlewares = [];
  capabilities = {};
  onErrorHandler;
  schemaAdapter;
  logger;
  tools = new Map;
  prompts = new Map;
  resources = new Map;
  notificationSender;
  clientRequestSender;
  constructor(options) {
    this.serverInfo = {
      name: options.name,
      version: options.version
    };
    this.schemaAdapter = options.schemaAdapter;
    this.logger = options.logger || console;
    this.methods = {
      [METHODS.INITIALIZE]: this.handleInitialize.bind(this),
      [METHODS.PING]: this.handlePing.bind(this),
      [METHODS.TOOLS.LIST]: this.handleToolsList.bind(this),
      [METHODS.TOOLS.CALL]: this.handleToolsCall.bind(this),
      [METHODS.PROMPTS.LIST]: this.handlePromptsList.bind(this),
      [METHODS.PROMPTS.GET]: this.handlePromptsGet.bind(this),
      [METHODS.RESOURCES.LIST]: this.handleResourcesList.bind(this),
      [METHODS.RESOURCES.TEMPLATES_LIST]: this.handleResourceTemplatesList.bind(this),
      [METHODS.RESOURCES.READ]: this.handleResourcesRead.bind(this),
      [METHODS.RESOURCES.SUBSCRIBE]: this.handleNotImplemented.bind(this),
      [METHODS.NOTIFICATIONS.CANCELLED]: this.handleNotificationCancelled.bind(this),
      [METHODS.NOTIFICATIONS.INITIALIZED]: this.handleNotificationInitialized.bind(this),
      [METHODS.NOTIFICATIONS.PROGRESS]: this.handleNotificationProgress.bind(this),
      [METHODS.NOTIFICATIONS.ROOTS.LIST_CHANGED]: this.handleNotificationRootsListChanged.bind(this),
      [METHODS.LOGGING.SET_LEVEL]: this.handleLoggingSetLevel.bind(this),
      [METHODS.RESOURCES.UNSUBSCRIBE]: this.handleNotImplemented.bind(this),
      [METHODS.COMPLETION.COMPLETE]: this.handleNotImplemented.bind(this)
    };
  }
  use(middleware) {
    this.middlewares.push(middleware);
    return this;
  }
  onError(handler) {
    this.onErrorHandler = handler;
    return this;
  }
  tool(name, def) {
    if (!this.capabilities.tools) {
      this.capabilities.tools = { listChanged: true };
    }
    const { resolvedSchema, validator } = resolveSchema(def.inputSchema, this.schemaAdapter);
    const outputSchemaResolved = resolveSchema(def.outputSchema, this.schemaAdapter);
    const metadata = {
      name,
      inputSchema: resolvedSchema
    };
    if (def.description) {
      metadata.description = def.description;
    }
    if (def.title) {
      metadata.title = def.title;
    }
    if (def._meta) {
      metadata._meta = def._meta;
    }
    if (outputSchemaResolved.resolvedSchema && def.outputSchema) {
      metadata.outputSchema = outputSchemaResolved.resolvedSchema;
    }
    const entry = {
      metadata,
      handler: def.handler,
      validator,
      outputValidator: outputSchemaResolved.validator
    };
    this.tools.set(name, entry);
    if (this.initialized) {
      this.notificationSender?.(undefined, {
        method: METHODS.NOTIFICATIONS.TOOLS.LIST_CHANGED
      });
    }
    return this;
  }
  resource(template, meta, validatorsOrHandler, handler) {
    if (!this.capabilities.resources) {
      this.capabilities.resources = { listChanged: true };
    }
    const actualHandler = handler || validatorsOrHandler;
    const validators = handler ? validatorsOrHandler : undefined;
    const isStatic = !template.includes("{");
    const type = isStatic ? "resource" : "resource_template";
    const matcher = isStatic ? undefined : compileUriTemplate(template);
    const metadata = isStatic ? {
      uri: template,
      ...meta
    } : {
      uriTemplate: template,
      ...meta
    };
    const entry = {
      metadata,
      handler: actualHandler,
      validators,
      matcher,
      type
    };
    this.resources.set(template, entry);
    if (this.initialized) {
      this.notificationSender?.(undefined, {
        method: METHODS.NOTIFICATIONS.RESOURCES.LIST_CHANGED
      });
    }
    return this;
  }
  prompt(name, def) {
    if (!this.capabilities.prompts) {
      this.capabilities.prompts = { listChanged: true };
    }
    let validator;
    let argumentDefs;
    if (def.arguments) {
      if (Array.isArray(def.arguments)) {
        argumentDefs = def.arguments;
      } else {
        const { resolvedSchema, validator: schemaValidator } = resolveSchema(def.arguments, this.schemaAdapter);
        validator = schemaValidator;
        argumentDefs = extractArgumentsFromSchema(resolvedSchema);
      }
    } else if (def.inputSchema) {
      const { resolvedSchema, validator: schemaValidator } = resolveSchema(def.inputSchema, this.schemaAdapter);
      validator = schemaValidator;
      argumentDefs = extractArgumentsFromSchema(resolvedSchema);
    }
    const metadata = {
      name,
      title: def.title,
      description: def.description
    };
    if (argumentDefs && argumentDefs.length > 0) {
      metadata.arguments = argumentDefs;
    }
    if (def._meta) {
      metadata._meta = def._meta;
    }
    const entry = {
      metadata,
      handler: def.handler,
      validator
    };
    this.prompts.set(name, entry);
    if (this.initialized) {
      this.notificationSender?.(undefined, {
        method: METHODS.NOTIFICATIONS.PROMPTS.LIST_CHANGED
      });
    }
    return this;
  }
  group(prefixOrOptionsOrChild, child) {
    let prefix = "";
    let suffix = "";
    let childServer;
    if (typeof prefixOrOptionsOrChild === "string") {
      prefix = prefixOrOptionsOrChild;
      childServer = child;
    } else if (prefixOrOptionsOrChild instanceof McpServer) {
      childServer = prefixOrOptionsOrChild;
    } else {
      prefix = prefixOrOptionsOrChild.prefix || "";
      suffix = prefixOrOptionsOrChild.suffix || "";
      childServer = child;
    }
    this.mountChild(prefix, suffix, childServer);
    return this;
  }
  _exportRegistries() {
    return {
      tools: Array.from(this.tools.entries()).map(([name, entry]) => ({
        name,
        entry
      })),
      prompts: Array.from(this.prompts.entries()).map(([name, entry]) => ({
        name,
        entry
      })),
      resources: Array.from(this.resources.entries()).map(([template, entry]) => ({ template, entry }))
    };
  }
  _exportMiddlewares() {
    return [...this.middlewares];
  }
  wrapWithMiddlewares(mws, handler) {
    return async (params, ctx) => {
      let result;
      let handlerCalled = false;
      await runMiddlewares(mws, ctx, async () => {
        result = await handler(params, ctx);
        handlerCalled = true;
      });
      if (!handlerCalled) {
        this.logger.error("[mcp-lite] Handler was not executed. A middleware in the child server's middleware chain did not call next(). This is a server configuration issue.");
        throw new RpcError(JSON_RPC_ERROR_CODES.INTERNAL_ERROR, "Internal server error");
      }
      return result;
    };
  }
  wrapResourceHandler(mws, handler) {
    return async (uri, vars, ctx) => {
      let result;
      let handlerCalled = false;
      await runMiddlewares(mws, ctx, async () => {
        result = await handler(uri, vars, ctx);
        handlerCalled = true;
      });
      if (!handlerCalled) {
        this.logger.error("[mcp-lite] Resource handler was not executed. A middleware in the child server's middleware chain did not call next(). This is a server configuration issue.");
        throw new RpcError(JSON_RPC_ERROR_CODES.INTERNAL_ERROR, "Internal server error");
      }
      if (!result) {
        this.logger.error("[mcp-lite] Resource handler returned no result. This is a server implementation issue.");
        throw new RpcError(JSON_RPC_ERROR_CODES.INTERNAL_ERROR, "Internal server error");
      }
      return result;
    };
  }
  mountChild(prefix, suffix, child) {
    const buildScopedName = (originalName) => {
      let scopedName = originalName;
      if (prefix)
        scopedName = `${prefix}/${scopedName}`;
      if (suffix)
        scopedName = `${scopedName}_${suffix}`;
      return scopedName;
    };
    const regs = child._exportRegistries();
    const childMWs = child._exportMiddlewares();
    let addedTools = 0;
    let addedPrompts = 0;
    let addedResources = 0;
    for (const { name, entry } of regs.tools) {
      const qualifiedName = buildScopedName(name);
      if (!this.tools.has(qualifiedName)) {
        const wrappedHandler = childMWs.length > 0 ? this.wrapWithMiddlewares(childMWs, entry.handler) : entry.handler;
        const wrappedEntry = {
          metadata: { ...entry.metadata, name: qualifiedName },
          handler: wrappedHandler,
          validator: entry.validator,
          outputValidator: entry.outputValidator
        };
        this.tools.set(qualifiedName, wrappedEntry);
        addedTools++;
      } else {
        this.logger.warn(`[mcp-lite] Tool '${qualifiedName}' already exists, skipping duplicate from child server. ` + `This follows keep-first semantics where the first registered tool wins.`);
      }
    }
    for (const { name, entry } of regs.prompts) {
      const qualifiedName = buildScopedName(name);
      if (!this.prompts.has(qualifiedName)) {
        const wrappedHandler = childMWs.length > 0 ? this.wrapWithMiddlewares(childMWs, entry.handler) : entry.handler;
        const wrappedEntry = {
          metadata: { ...entry.metadata, name: qualifiedName },
          handler: wrappedHandler,
          validator: entry.validator
        };
        this.prompts.set(qualifiedName, wrappedEntry);
        addedPrompts++;
      } else {
        this.logger.warn(`[mcp-lite] Prompt '${qualifiedName}' already exists, skipping duplicate from child server. ` + `This follows keep-first semantics where the first registered prompt wins.`);
      }
    }
    for (const { template, entry } of regs.resources) {
      if (!this.resources.has(template)) {
        const wrappedHandler = childMWs.length > 0 ? this.wrapResourceHandler(childMWs, entry.handler) : entry.handler;
        const wrappedEntry = {
          ...entry,
          handler: wrappedHandler
        };
        this.resources.set(template, wrappedEntry);
        addedResources++;
      } else {
        this.logger.warn(`[mcp-lite] Resource '${template}' already exists, skipping duplicate from child server. ` + `This follows keep-first semantics where the first registered resource wins.`);
      }
    }
    if (addedTools > 0 && !this.capabilities.tools) {
      this.capabilities.tools = { listChanged: true };
    }
    if (addedPrompts > 0 && !this.capabilities.prompts) {
      this.capabilities.prompts = { listChanged: true };
    }
    if (addedResources > 0 && !this.capabilities.resources) {
      this.capabilities.resources = { listChanged: true };
    }
    if (this.initialized) {
      if (addedTools > 0) {
        this.notificationSender?.(undefined, {
          method: METHODS.NOTIFICATIONS.TOOLS.LIST_CHANGED
        });
      }
      if (addedPrompts > 0) {
        this.notificationSender?.(undefined, {
          method: METHODS.NOTIFICATIONS.PROMPTS.LIST_CHANGED
        });
      }
      if (addedResources > 0) {
        this.notificationSender?.(undefined, {
          method: METHODS.NOTIFICATIONS.RESOURCES.LIST_CHANGED
        });
      }
    }
  }
  _setNotificationSender(sender) {
    this.notificationSender = sender;
  }
  _setClientRequestSender(sender) {
    this.clientRequestSender = sender;
  }
  async _dispatch(message, contextOptions = {}) {
    const isNotification = isJsonRpcNotification(message);
    const requestId = isNotification ? undefined : message.id;
    const progressToken = getProgressToken(message);
    const sessionId = contextOptions.sessionId;
    const progressSender = sessionId && this.notificationSender && progressToken ? (update) => this.notificationSender?.(sessionId, {
      method: METHODS.NOTIFICATIONS.PROGRESS,
      params: {
        progressToken,
        ...update
      }
    }, { relatedRequestId: requestId ?? undefined }) : undefined;
    const ctx = createContext(message, requestId, {
      sessionId,
      sessionProtocolVersion: contextOptions.sessionProtocolVersion,
      progressToken,
      progressSender,
      authInfo: contextOptions.authInfo,
      clientCapabilities: contextOptions.clientCapabilities,
      schemaAdapter: this.schemaAdapter,
      clientRequestSender: this.clientRequestSender
    });
    const method = message.method;
    const handler = this.methods[method];
    const tail = async () => {
      if (!handler) {
        if (requestId === undefined) {
          return;
        }
        ctx.response = createJsonRpcError(requestId, new RpcError(JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND, "Method not found", method ? { method } : undefined).toJson());
        return;
      }
      const result = await handler(message.params, ctx);
      if (requestId !== undefined) {
        ctx.response = createJsonRpcResponse(requestId, result);
      }
    };
    try {
      await runMiddlewares(this.middlewares, ctx, tail);
      if (requestId === undefined) {
        return null;
      }
      if (!ctx.response) {
        return createJsonRpcError(requestId, new RpcError(JSON_RPC_ERROR_CODES.INTERNAL_ERROR, "No response generated").toJson());
      }
      return ctx.response;
    } catch (error) {
      if (requestId === undefined) {
        return null;
      }
      if (this.onErrorHandler) {
        try {
          const customError = await this.onErrorHandler(error, ctx);
          if (customError) {
            return createJsonRpcError(requestId, customError);
          }
        } catch (_handlerError) {}
      }
      return errorToResponse(error, requestId);
    }
  }
  async handleToolsList(_params, _ctx) {
    return {
      tools: Array.from(this.tools.values()).map((t) => t.metadata)
    };
  }
  async handleToolsCall(params, ctx) {
    if (!isObject(params)) {
      throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, "tools/call requires an object with name and arguments");
    }
    const callParams = params;
    if (!isString(callParams.name)) {
      throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, "tools/call requires a string 'name' field");
    }
    const toolName = callParams.name;
    const entry = this.tools.get(toolName);
    if (!entry) {
      throw new RpcError(JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND, "Method not found", { method: toolName });
    }
    let validatedArgs = callParams.arguments;
    if (entry.validator) {
      validatedArgs = ctx.validate(entry.validator, callParams.arguments);
    }
    const result = await entry.handler(validatedArgs, ctx);
    if (entry.outputValidator && "structuredContent" in result && !result.isError) {
      try {
        const validated = createValidationFunction(entry.outputValidator, result.structuredContent);
        result.structuredContent = validated;
      } catch (validationError) {
        throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, `Tool '${toolName}' returned invalid structured content: ${validationError instanceof Error ? validationError.message : String(validationError)}`);
      }
    }
    return result;
  }
  async handlePromptsList(_params, _ctx) {
    return {
      prompts: Array.from(this.prompts.values()).map((p) => p.metadata)
    };
  }
  async handlePromptsGet(params, ctx) {
    if (!isObject(params)) {
      throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, "prompts/get requires an object with name and arguments");
    }
    const getParams = params;
    if (!isString(getParams.name)) {
      throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, "prompts/get requires a string 'name' field");
    }
    const promptName = getParams.name;
    const entry = this.prompts.get(promptName);
    if (!entry) {
      throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, "Invalid prompt name", { name: promptName });
    }
    let validatedArgs = getParams.arguments || {};
    if (entry.validator) {
      validatedArgs = ctx.validate(entry.validator, getParams.arguments);
    }
    const result = await entry.handler(validatedArgs, ctx);
    return result;
  }
  async handleResourcesList(_params, _ctx) {
    const resources = Array.from(this.resources.values()).filter((entry) => entry.type === "resource").map((entry) => entry.metadata);
    return { resources };
  }
  async handleResourceTemplatesList(_params, _ctx) {
    const resourceTemplates = Array.from(this.resources.values()).filter((entry) => entry.type === "resource_template").map((entry) => entry.metadata);
    return { resourceTemplates };
  }
  async handleResourcesRead(params, ctx) {
    if (typeof params !== "object" || params === null) {
      throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, "resources/read requires an object with uri");
    }
    const readParams = params;
    if (typeof readParams.uri !== "string") {
      throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, "resources/read requires a string 'uri' field");
    }
    const uri = readParams.uri;
    let matchedEntry = null;
    let vars = {};
    const directEntry = this.resources.get(uri);
    if (directEntry?.type === "resource") {
      matchedEntry = directEntry;
    }
    if (!matchedEntry) {
      for (const entry of this.resources.values()) {
        if (entry.type === "resource_template" && entry.matcher) {
          const matchResult = entry.matcher.match(uri);
          if (matchResult !== null) {
            matchedEntry = entry;
            vars = matchResult;
            break;
          }
        }
      }
    }
    if (!matchedEntry) {
      throw new RpcError(JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND, "Method not found", { uri });
    }
    let validatedVars = vars;
    if (matchedEntry.validators) {
      validatedVars = {};
      for (const [key, validator] of Object.entries(matchedEntry.validators)) {
        if (key in vars) {
          try {
            validatedVars[key] = ctx.validate(validator, vars[key]);
          } catch (validationError) {
            throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, `Validation failed for parameter '${key}': ${validationError instanceof Error ? validationError.message : String(validationError)}`);
          }
        }
      }
      for (const [key, value] of Object.entries(vars)) {
        if (!(key in matchedEntry.validators)) {
          validatedVars[key] = value;
        }
      }
    }
    try {
      const url = { href: uri };
      const result = await matchedEntry.handler(url, validatedVars, ctx);
      return result;
    } catch (error) {
      if (error instanceof RpcError) {
        throw error;
      }
      throw new RpcError(JSON_RPC_ERROR_CODES.INTERNAL_ERROR, "Internal error", error instanceof Error ? { message: error.message } : error);
    }
  }
  async handleInitialize(params, _ctx) {
    if (!isInitializeParams(params)) {
      throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, "Invalid initialize parameters");
    }
    const initParams = params;
    const requested = initParams.protocolVersion;
    let negotiatedVersion;
    if (isSupportedVersion(requested)) {
      negotiatedVersion = requested;
    } else {
      negotiatedVersion = SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_03_26;
      this.logger?.warn?.(`Client requested unsupported protocol version ${requested}, negotiating to ${negotiatedVersion}`);
    }
    this.initialized = true;
    return {
      protocolVersion: negotiatedVersion,
      serverInfo: this.serverInfo,
      capabilities: this.capabilities
    };
  }
  async handlePing() {
    return {};
  }
  async handleNotificationCancelled(_params, _ctx) {
    return {};
  }
  async handleNotificationInitialized(_params, _ctx) {
    return {};
  }
  async handleNotificationProgress(_params, _ctx) {
    return {};
  }
  async handleNotificationRootsListChanged(_params, _ctx) {
    return {};
  }
  async handleLoggingSetLevel(_params, _ctx) {
    return {};
  }
  async handleNotImplemented(_params, ctx) {
    throw new RpcError(JSON_RPC_ERROR_CODES.INTERNAL_ERROR, "Not implemented", {
      method: ctx.request.method
    });
  }
}
// src/session-store.ts
function formatEventId(sequenceNumber, streamId) {
  return `${sequenceNumber}#${streamId}`;
}
function parseEventId(eventId) {
  const hashIndex = eventId.lastIndexOf("#");
  if (hashIndex === -1) {
    throw new Error(`Invalid event ID format: ${eventId}`);
  }
  const seqStr = eventId.slice(0, hashIndex);
  const streamId = eventId.slice(hashIndex + 1);
  const n = parseInt(seqStr, 10);
  if (!Number.isFinite(n) || n < 1) {
    throw new Error(`Invalid sequence number in event ID: ${eventId}`);
  }
  return {
    sequenceNumber: n,
    streamId
  };
}

class InMemorySessionAdapter {
  #sessions = new Map;
  maxEventBufferSize;
  constructor({ maxEventBufferSize }) {
    this.maxEventBufferSize = maxEventBufferSize;
  }
  generateSessionId() {
    return crypto.randomUUID();
  }
  create(id, meta) {
    const session = {
      meta,
      streams: new Map
    };
    this.#sessions.set(id, session);
    return session;
  }
  has(id) {
    return this.#sessions.has(id);
  }
  get(id) {
    return this.#sessions.get(id);
  }
  delete(id) {
    this.#sessions.delete(id);
  }
  appendEvent(id, streamId, message) {
    const session = this.get(id);
    if (!session) {
      return;
    }
    let streamData = session.streams.get(streamId);
    if (!streamData) {
      streamData = {
        nextEventId: 1,
        eventBuffer: []
      };
      session.streams.set(streamId, streamData);
    }
    const eventId = formatEventId(streamData.nextEventId++, streamId);
    streamData.eventBuffer.push({ id: eventId, message });
    if (streamData.eventBuffer.length > this.maxEventBufferSize) {
      streamData.eventBuffer = streamData.eventBuffer.slice(-this.maxEventBufferSize);
    }
    return eventId;
  }
  async replay(id, lastEventId, write) {
    const session = this.#sessions.get(id);
    if (!session) {
      return;
    }
    const { sequenceNumber: lastSeq, streamId: targetStreamId } = parseEventId(lastEventId);
    const streamData = session.streams.get(targetStreamId);
    if (!streamData) {
      return;
    }
    for (const event of streamData.eventBuffer) {
      const { sequenceNumber: eventSeq } = parseEventId(event.id);
      if (eventSeq > lastSeq) {
        await write(event.id, event.message);
      }
    }
  }
}
// src/sse-writer.ts
function createSSEStream(options) {
  const encoder = new TextEncoder;
  let controller;
  let closed = false;
  const end = () => {
    if (closed)
      return;
    closed = true;
    try {
      controller.close();
    } catch (_error) {}
    try {
      options?.onClose?.();
    } catch (_e) {}
  };
  const stream = new ReadableStream({
    start(c) {
      controller = c;
    },
    cancel() {
      end();
    }
  });
  const writer = {
    write(message, eventId) {
      if (closed)
        return;
      try {
        let sse = "";
        if (eventId)
          sse += `id: ${eventId}
`;
        sse += `data: ${JSON.stringify(message)}

`;
        controller.enqueue(encoder.encode(sse));
      } catch (_error) {
        end();
      }
    },
    end
  };
  return { stream, writer };
}

// src/transport-http/http-responses.ts
function respondToInvalidJsonRpc() {
  const errorResponse = createJsonRpcError(null, new RpcError(JSON_RPC_ERROR_CODES.INVALID_REQUEST, "Invalid JSON-RPC 2.0 message format").toJson());
  return new Response(JSON.stringify(errorResponse), {
    status: 400,
    headers: {
      "Content-Type": "application/json"
    }
  });
}
function respondToProtocolMismatch(responseId, protocolHeader, expected) {
  const expectedVersion = expected || SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST;
  const errorResponse = createJsonRpcError(responseId, new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, "Protocol version mismatch", {
    expectedVersion,
    receivedVersion: protocolHeader
  }).toJson());
  return new Response(JSON.stringify(errorResponse), {
    status: 400,
    headers: {
      "Content-Type": "application/json"
    }
  });
}
function respondToMissingProtocolHeader(responseId) {
  const errorResponse = createJsonRpcError(responseId, new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, "Missing required MCP-Protocol-Version header", {
    requiredHeader: "MCP-Protocol-Version"
  }).toJson());
  return new Response(JSON.stringify(errorResponse), {
    status: 400,
    headers: {
      "Content-Type": "application/json"
    }
  });
}
function respondToMissingSessionId() {
  return new Response("Bad Request: Missing required session ID", {
    status: 400,
    headers: {
      "Content-Type": "text/plain"
    }
  });
}

// src/transport-http/transport-http.ts
function parseJsonRpc(body) {
  try {
    const parsed = JSON.parse(body);
    return parsed;
  } catch (_error) {
    throw new RpcError(JSON_RPC_ERROR_CODES.PARSE_ERROR, "Invalid JSON");
  }
}

class StreamableHttpTransport {
  server;
  sessionAdapter;
  clientRequestAdapter;
  allowedOrigins;
  allowedHosts;
  sessionStreams = new Map;
  requestStreams = new Map;
  constructor(options = {}) {
    this.sessionAdapter = options.sessionAdapter;
    this.clientRequestAdapter = options.clientRequestAdapter;
    this.allowedOrigins = options.allowedOrigins;
    this.allowedHosts = options.allowedHosts;
  }
  getRequestWriter(sessionId, requestId) {
    return this.requestStreams.get(`${sessionId}:${requestId}`);
  }
  getSessionWriter(sessionId) {
    return this.sessionStreams.get(sessionId);
  }
  cleanupSession(sessionId) {
    const sessionWriter = this.sessionStreams.get(sessionId);
    if (sessionWriter) {
      sessionWriter.end();
    }
    this.sessionStreams.delete(sessionId);
    for (const [key, writer] of this.requestStreams) {
      if (key.startsWith(`${sessionId}:`)) {
        writer.end();
        this.requestStreams.delete(key);
      }
    }
  }
  async getClientCapabilities(sessionId) {
    if (!sessionId) {
      return;
    }
    if (!this.sessionAdapter) {
      return {};
    }
    try {
      const sessionData = await this.sessionAdapter.get(sessionId);
      return sessionData?.meta?.clientCapabilities;
    } catch {
      return;
    }
  }
  async getSessionProtocolVersion(sessionId) {
    if (!sessionId || !this.sessionAdapter) {
      return;
    }
    try {
      const sessionData = await this.sessionAdapter.get(sessionId);
      return sessionData?.meta?.protocolVersion;
    } catch {
      return;
    }
  }
  async sendClientRequest(sessionId, request, options) {
    if (!this.clientRequestAdapter) {
      throw new Error("Client request adapter not configured");
    }
    if (request.id === null || request.id === undefined) {
      throw new Error("Client request must have a valid id");
    }
    const { promise } = this.clientRequestAdapter.createPending(sessionId, request.id, { timeout_ms: options?.timeout_ms });
    const jsonRpcRequest = {
      jsonrpc: JSON_RPC_VERSION,
      id: request.id,
      method: request.method,
      params: request.params
    };
    let delivered = false;
    if (sessionId && options?.relatedRequestId !== undefined) {
      const requestWriter = this.getRequestWriter(sessionId, options.relatedRequestId);
      if (requestWriter) {
        requestWriter.write(jsonRpcRequest);
        delivered = true;
      }
    }
    if (!delivered && sessionId) {
      const sessionWriter = this.getSessionWriter(sessionId);
      if (sessionWriter) {
        sessionWriter.write(jsonRpcRequest);
        delivered = true;
      }
    }
    if (!delivered) {
      this.clientRequestAdapter.rejectPending(sessionId, request.id, new Error("No active streams to deliver client request"));
      throw new Error("No active streams to deliver client request");
    }
    return promise;
  }
  bind(server) {
    this.server = server;
    if (this.clientRequestAdapter) {
      server._setClientRequestSender(this.sendClientRequest.bind(this));
    }
    server._setNotificationSender(async (sessionId, notification, options) => {
      const jsonRpcNotification = {
        jsonrpc: JSON_RPC_VERSION,
        method: notification.method,
        params: notification.params
      };
      if (this.sessionAdapter) {
        const relatedRequestId = options?.relatedRequestId;
        if (sessionId) {
          let eventId;
          if (this.sessionAdapter) {
            eventId = await this.sessionAdapter.appendEvent(sessionId, SSE_STREAM_ID, jsonRpcNotification);
          }
          if (relatedRequestId !== undefined) {
            const requestWriter = this.getRequestWriter(sessionId, relatedRequestId);
            if (requestWriter) {
              requestWriter.write(jsonRpcNotification);
              return;
            }
          }
          const sessionWriter = this.getSessionWriter(sessionId);
          if (sessionWriter) {
            sessionWriter.write(jsonRpcNotification, eventId);
          }
        }
        const shouldBroadcastToAllSessions = !sessionId || isGlobalNotification(notification.method);
        if (shouldBroadcastToAllSessions) {
          for (const [sid, writer] of this.sessionStreams) {
            if (sid !== sessionId) {
              writer.write(jsonRpcNotification);
            }
          }
        }
      } else {
        if (options?.relatedRequestId && sessionId) {
          const requestWriter = this.getRequestWriter(sessionId, options.relatedRequestId);
          if (requestWriter) {
            requestWriter.write(jsonRpcNotification);
          }
        }
        const shouldBroadcastToAllRequests = !sessionId || isGlobalNotification(notification.method);
        if (shouldBroadcastToAllRequests) {
          for (const [requestKey, writer] of this.requestStreams) {
            if (!sessionId || !requestKey.startsWith(`${sessionId}:`)) {
              writer.write(jsonRpcNotification);
            }
          }
        }
      }
    });
    return this.handleRequest.bind(this);
  }
  async handleRequest(request, options) {
    if (!this.server) {
      throw new Error("Transport not bound to a server");
    }
    if (this.allowedHosts) {
      const host = request.headers.get("Host");
      if (host && !this.allowedHosts.includes(host)) {
        return new Response("Forbidden", { status: 403 });
      }
    }
    if (this.allowedOrigins) {
      const origin = request.headers.get("Origin");
      if (origin && !this.allowedOrigins.includes(origin)) {
        return new Response("Forbidden", { status: 403 });
      }
    }
    switch (request.method) {
      case "POST":
        return this.handlePost(request, { authInfo: options?.authInfo });
      case "GET":
        return this.handleGet(request);
      case "DELETE":
        return this.handleDelete(request);
      default: {
        const errorResponse = createJsonRpcError(null, new RpcError(JSON_RPC_ERROR_CODES.INVALID_REQUEST, "Method not supported").toJson());
        return new Response(JSON.stringify(errorResponse), {
          status: 405,
          headers: {
            Allow: "POST, GET, DELETE"
          }
        });
      }
    }
  }
  validateProtocolHeader(sessionVersion, protocolHeader, jsonRpcMessage, isNotification) {
    const responseId = isNotification ? null : jsonRpcMessage.id;
    if (sessionVersion === SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_06_18) {
      if (!protocolHeader) {
        return respondToMissingProtocolHeader(responseId);
      }
      if (protocolHeader !== sessionVersion) {
        return respondToProtocolMismatch(responseId, protocolHeader, sessionVersion);
      }
      return null;
    }
    if (sessionVersion === SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_03_26) {
      if (protocolHeader && protocolHeader !== sessionVersion) {
        return respondToProtocolMismatch(responseId, protocolHeader, sessionVersion);
      }
      return null;
    }
    if (protocolHeader && !SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST.includes(protocolHeader)) {
      return respondToProtocolMismatch(responseId, protocolHeader, SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST);
    }
    return null;
  }
  async handlePost(request, options) {
    try {
      const sessionId = request.headers.get(MCP_SESSION_ID_HEADER);
      const body = await request.text();
      const jsonRpcMessage = parseJsonRpc(body);
      if (Array.isArray(jsonRpcMessage)) {
        let sessionVersion;
        if (this.sessionAdapter && sessionId) {
          const session = await this.sessionAdapter.get(sessionId);
          sessionVersion = session?.meta?.protocolVersion;
        }
        if (sessionVersion === SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_03_26) {
          return this.handleBatchRequest(jsonRpcMessage, sessionId, options);
        }
        const errorResponse = createJsonRpcError(null, new RpcError(JSON_RPC_ERROR_CODES.INVALID_REQUEST, "Batch requests are not supported in protocol version 2025-06-18").toJson());
        return new Response(JSON.stringify(errorResponse), {
          status: 400,
          headers: { "Content-Type": "application/json" }
        });
      }
      if (isJsonRpcResponse(jsonRpcMessage)) {
        if (this.sessionAdapter && !sessionId) {
          return respondToMissingSessionId();
        }
        if (this.clientRequestAdapter && jsonRpcMessage.id !== null && jsonRpcMessage.id !== undefined) {
          this.clientRequestAdapter.resolvePending(sessionId || undefined, jsonRpcMessage.id, jsonRpcMessage);
        }
        return new Response(null, { status: 202 });
      }
      if (!isJsonRpcNotification(jsonRpcMessage) && !isJsonRpcRequest(jsonRpcMessage)) {
        return respondToInvalidJsonRpc();
      }
      const isNotification = isJsonRpcNotification(jsonRpcMessage);
      const isInitializeRequest = jsonRpcMessage.method === "initialize";
      const acceptHeader = request.headers.get("Accept");
      const protocolHeader = request.headers.get(MCP_PROTOCOL_HEADER);
      if (!isInitializeRequest) {
        let sessionVersion;
        if (this.sessionAdapter && sessionId) {
          const session = await this.sessionAdapter.get(sessionId);
          sessionVersion = session?.meta?.protocolVersion;
        }
        const validationError = this.validateProtocolHeader(sessionVersion, protocolHeader, jsonRpcMessage, isNotification);
        if (validationError) {
          return validationError;
        }
      }
      if (this.sessionAdapter && !sessionId && !isInitializeRequest) {
        return respondToMissingSessionId();
      }
      if (!isInitializeRequest && !isNotification && acceptHeader?.includes(SSE_ACCEPT_HEADER)) {
        return this.handlePostSse({
          request,
          jsonRpcRequest: jsonRpcMessage,
          sessionId,
          isNotification,
          authInfo: options?.authInfo
        });
      }
      const response = await this.server?._dispatch(jsonRpcMessage, {
        sessionId: sessionId || undefined,
        sessionProtocolVersion: await this.getSessionProtocolVersion(sessionId),
        authInfo: options?.authInfo,
        clientCapabilities: await this.getClientCapabilities(sessionId)
      });
      if (isInitializeRequest && response) {
        if (this.sessionAdapter) {
          const sessionId2 = this.sessionAdapter.generateSessionId();
          const initParams = jsonRpcMessage.params;
          const negotiatedVersion = response.result?.protocolVersion || SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_06_18;
          const sessionMeta = {
            protocolVersion: negotiatedVersion,
            clientInfo: initParams.clientInfo,
            clientCapabilities: initParams.capabilities
          };
          await this.sessionAdapter.create(sessionId2, sessionMeta);
          return new Response(JSON.stringify(response), {
            status: 200,
            headers: {
              "Content-Type": "application/json",
              [MCP_SESSION_ID_HEADER]: sessionId2
            }
          });
        }
        return new Response(JSON.stringify(response), {
          status: 200,
          headers: {
            "Content-Type": "application/json"
          }
        });
      }
      if (response === null) {
        return new Response(null, { status: 202 });
      } else {
        const headers = {
          "Content-Type": "application/json"
        };
        if (this.sessionAdapter && !isInitializeRequest) {
          const sessionId2 = request.headers.get(MCP_SESSION_ID_HEADER);
          if (sessionId2) {
            headers[MCP_SESSION_ID_HEADER] = sessionId2;
          }
        }
        return new Response(JSON.stringify(response), {
          status: 200,
          headers
        });
      }
    } catch (error) {
      const errorResponse = createJsonRpcError(null, new RpcError(JSON_RPC_ERROR_CODES.PARSE_ERROR, "Parse error", error instanceof Error ? error.message : "Unknown parsing error").toJson());
      return new Response(JSON.stringify(errorResponse), {
        status: 400,
        headers: {
          "Content-Type": "application/json"
        }
      });
    }
  }
  async handleBatchRequest(batch, sessionId, options) {
    const responses = [];
    const sessionProtocolVersion = await this.getSessionProtocolVersion(sessionId);
    const clientCapabilities = await this.getClientCapabilities(sessionId);
    for (const message of batch) {
      if (!isJsonRpcRequest(message) && !isJsonRpcNotification(message)) {
        responses.push(createJsonRpcError(null, new RpcError(JSON_RPC_ERROR_CODES.INVALID_REQUEST, "Invalid JSON-RPC 2.0 message in batch").toJson()));
        continue;
      }
      try {
        const response = await this.server?._dispatch(message, {
          sessionId: sessionId || undefined,
          sessionProtocolVersion,
          authInfo: options?.authInfo,
          clientCapabilities
        });
        if (response !== null && response !== undefined) {
          responses.push(response);
        }
      } catch (error) {
        const errorResponse = createJsonRpcError(message.id || null, new RpcError(JSON_RPC_ERROR_CODES.INTERNAL_ERROR, "Internal error processing batch item", error instanceof Error ? error.message : "Unknown error").toJson());
        responses.push(errorResponse);
      }
    }
    return new Response(JSON.stringify(responses), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        ...this.sessionAdapter && sessionId ? { [MCP_SESSION_ID_HEADER]: sessionId } : {}
      }
    });
  }
  async handlePostSse(args) {
    const { jsonRpcRequest, sessionId, isNotification, authInfo } = args;
    if (isNotification) {
      return new Response("Bad Request: POST SSE requires a request with 'id' (notifications not supported)", {
        status: 400
      });
    }
    const requestId = jsonRpcRequest.id;
    if (requestId === null || requestId === undefined) {
      return new Response("Bad Request: POST SSE requires a request with 'id'", {
        status: 400
      });
    }
    const effectiveSessionId = sessionId || crypto.randomUUID();
    const { stream, writer } = createSSEStream({
      onClose: () => {
        this.requestStreams.delete(`${effectiveSessionId}:${requestId}`);
      }
    });
    this.requestStreams.set(`${effectiveSessionId}:${requestId}`, writer);
    Promise.resolve(this.server?._dispatch(jsonRpcRequest, {
      sessionId: effectiveSessionId,
      sessionProtocolVersion: await this.getSessionProtocolVersion(effectiveSessionId),
      authInfo,
      clientCapabilities: await this.getClientCapabilities(effectiveSessionId)
    })).then(async (rpcResponse) => {
      if (rpcResponse !== null) {
        writer.write(rpcResponse);
      }
    }).catch((err) => {
      try {
        const responseId = jsonRpcRequest.id;
        if (responseId !== null && responseId !== undefined) {
          const errorResponse = createJsonRpcError(responseId, new RpcError(JSON_RPC_ERROR_CODES.INTERNAL_ERROR, "Internal error", err instanceof Error ? { message: err.message } : err).toJson());
          writer.write(errorResponse);
        }
      } catch (_) {}
    }).finally(() => {
      writer.end();
      this.requestStreams.delete(`${effectiveSessionId}:${requestId}`);
    });
    const headers = {
      "Content-Type": SSE_ACCEPT_HEADER,
      Connection: "keep-alive"
    };
    if (this.sessionAdapter && sessionId) {
      headers[MCP_SESSION_ID_HEADER] = sessionId;
    }
    return new Response(stream, {
      status: 200,
      headers
    });
  }
  async handleGet(request) {
    const accept = request.headers.get("Accept");
    if (!accept || !accept.includes(SSE_ACCEPT_HEADER)) {
      return new Response("Bad Request: Accept header must be text/event-stream", {
        status: 400
      });
    }
    const protocolHeader = request.headers.get(MCP_PROTOCOL_HEADER);
    if (protocolHeader && protocolHeader !== SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_06_18) {
      return new Response("Bad Request: Protocol version mismatch", {
        status: 400
      });
    }
    if (!this.sessionAdapter) {
      return new Response("Method Not Allowed", { status: 405 });
    }
    const sessionId = request.headers.get(MCP_SESSION_ID_HEADER);
    if (!sessionId || !await this.sessionAdapter?.has(sessionId)) {
      return new Response("Bad Request: Invalid or missing session ID", {
        status: 400
      });
    }
    if (this.sessionStreams.has(sessionId)) {
      return new Response("Conflict: Stream already exists for session", {
        status: 409
      });
    }
    const { stream, writer } = createSSEStream({
      onClose: () => this.sessionStreams.delete(sessionId)
    });
    this.sessionStreams.set(sessionId, writer);
    const lastEventId = request.headers.get(MCP_LAST_EVENT_ID_HEADER);
    let attemptedReplay = false;
    if (lastEventId) {
      attemptedReplay = true;
      try {
        await this.sessionAdapter.replay(sessionId, lastEventId, (eid, msg) => {
          writer.write(msg, eid);
        });
      } catch (_error) {
        writer.end();
        return new Response("Internal Server Error: Replay failed", {
          status: 500
        });
      }
    }
    if (!attemptedReplay) {
      const pingNotification = {
        jsonrpc: JSON_RPC_VERSION,
        method: "ping",
        params: {}
      };
      writer.write(pingNotification);
    }
    return new Response(stream, {
      status: 200,
      headers: {
        "Content-Type": SSE_ACCEPT_HEADER,
        Connection: "keep-alive",
        [MCP_SESSION_ID_HEADER]: sessionId
      }
    });
  }
  async handleDelete(request) {
    const sessionId = request.headers.get(MCP_SESSION_ID_HEADER);
    if (!this.sessionAdapter) {
      return new Response("Method Not Allowed", { status: 405 });
    }
    if (!sessionId) {
      return new Response("Bad Request: Missing session ID", {
        status: 400
      });
    }
    this.cleanupSession(sessionId);
    await this.sessionAdapter.delete(sessionId);
    return new Response(null, { status: 200 });
  }
}
export {
  isJsonRpcRequest,
  isJsonRpcNotification,
  createJsonRpcResponse,
  createJsonRpcError,
  StreamableHttpTransport,
  SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST,
  SUPPORTED_MCP_PROTOCOL_VERSIONS,
  SSE_ACCEPT_HEADER,
  RpcError,
  McpServer,
  MCP_SESSION_ID_HEADER,
  MCP_PROTOCOL_HEADER,
  JSON_RPC_ERROR_CODES,
  InMemorySessionAdapter,
  InMemoryClientRequestAdapter
};

//# debugId=C36562CABF59002464756E2164756E21
//# sourceMappingURL=index.js.map
