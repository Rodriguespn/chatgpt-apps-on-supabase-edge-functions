import type { StandardSchemaV1 } from "@standard-schema/spec";
import { type CreateContextOptions } from "./context.js";
import type { InferOutput, JsonRpcNotification, JsonRpcReq, JsonRpcRes, MCPServerContext, Middleware, OnError, PromptEntry, PromptHandler, ResourceEntry, ResourceHandler, ResourceMeta, ResourceVarValidators, SchemaAdapter, ToolCallResult, ToolEntry } from "./types.js";
/**
 * Logger interface for MCP server internal logging.
 * Defaults to console if not provided.
 */
export interface Logger {
    error(message: string, ...args: unknown[]): void;
    warn(message: string, ...args: unknown[]): void;
    info(message: string, ...args: unknown[]): void;
    debug(message: string, ...args: unknown[]): void;
}
export interface McpServerOptions {
    name: string;
    version: string;
    /**
     * A function that converts a StandardSchema to a JSON Schema
     *
     * In practice, you will need to coerce the `schema` parameter of this function to the correct type for the library you are using,
     * in order to pass it to a helper that handles converting to JSON Schema.
     *
     * @example Using Zod
     * ```typescript
     * import { z } from "zod";
     *
     * const server = new McpServer({
     *   // ...
     *   schemaAdapter: (schema) => z.toJSONSchema(schema as z.ZodType),
     * });
     * ```
     */
    schemaAdapter?: SchemaAdapter;
    /**
     * Logger for internal server messages.
     * Defaults to console if not provided.
     *
     * @example Using a custom logger
     * ```typescript
     * const server = new McpServer({
     *   name: "my-server",
     *   version: "1.0.0",
     *   logger: {
     *     error: (msg, ...args) => myLogger.error(msg, ...args),
     *     warn: (msg, ...args) => myLogger.warn(msg, ...args),
     *     info: (msg, ...args) => myLogger.info(msg, ...args),
     *     debug: (msg, ...args) => myLogger.debug(msg, ...args),
     *   }
     * });
     * ```
     *
     * @example Disabling logs
     * ```typescript
     * const server = new McpServer({
     *   name: "my-server",
     *   version: "1.0.0",
     *   logger: {
     *     error: () => {},
     *     warn: () => {},
     *     info: () => {},
     *     debug: () => {},
     *   }
     * });
     * ```
     */
    logger?: Logger;
}
/**
 * MCP (Model Context Protocol) Server implementation.
 *
 * Provides a framework for building MCP-compliant servers that can expose tools, prompts,
 * and resources to MCP clients. The server handles JSON-RPC 2.0 communication and protocol
 * negotiation according to the MCP specification.
 *
 * @example Basic server setup
 * ```typescript
 * import { McpServer, StreamableHttpTransport } from "mcp-lite";
 *
 * // Create server instance
 * const server = new McpServer({
 *   name: "my-server",
 *   version: "1.0.0"
 * });
 *
 * // Add a tool
 * server.tool("echo", {
 *   description: "Echoes the input message",
 *   inputSchema: {
 *     type: "object",
 *     properties: {
 *       message: { type: "string" }
 *     },
 *     required: ["message"]
 *   },
 *   handler: (args: { message: string }) => ({
 *     content: [{ type: "text", text: args.message }]
 *   })
 * });
 *
 * // Create HTTP transport and bind server
 * const transport = new StreamableHttpTransport();
 * const httpHandler = transport.bind(server);
 *
 * // Use with your HTTP framework
 * app.post("/mcp", async (req) => {
 *   const response = await httpHandler(req);
 *   return response;
 * });
 * ```
 *
 * @example Using middleware
 * ```typescript
 * server.use(async (ctx, next) => {
 *   console.log("Request:", ctx.request.method);
 *   await next();
 *   console.log("Response:", ctx.response?.result);
 * });
 * ```
 *
 * @example Tool with Standard Schema validation (Zod, Valibot, etc.)
 * ```typescript
 * import { z } from "zod";
 *
 * const inputSchema = z.object({
 *   value: z.number()
 * });
 *
 * server.tool("double", {
 *   description: "Doubles a number",
 *   inputSchema, // Standard Schema validator
 *   handler: (args: { value: number }) => ({
 *     content: [{ type: "text", text: String(args.value * 2) }]
 *   })
 * });
 * ```
 *
 * @example Error handling
 * ```typescript
 * server.onError((error, ctx) => {
 *   console.error("Error in request:", ctx.requestId, error);
 *   return {
 *     code: -32000,
 *     message: "Custom error message",
 *     data: { requestId: ctx.requestId }
 *   };
 * });
 * ```
 *
 * ## Core Features
 *
 * ### Tools
 * Tools are functions that can be called by MCP clients. They must return content in the
 * `ToolCallResult` format with a `content` array.
 *
 * ### Input Validation
 * - **JSON Schema**: Standard JSON Schema objects for validation
 * - **Standard Schema**: Support for Zod, Valibot, and other Standard Schema validators
 * - **No Schema**: Basic object validation when no schema provided
 *
 * ### Middleware Support
 * Middleware functions run before request handlers and can modify context, add logging,
 * implement authentication, etc.
 *
 * ### Transport Agnostic
 * The server core is transport-agnostic. Use `StreamableHttpTransport` for HTTP/REST
 * or implement custom transports for WebSockets, stdio, etc.
 *
 * ### Protocol Compliance
 * - Full MCP specification compliance
 * - JSON-RPC 2.0 protocol support
 * - Protocol version negotiation
 * - Proper error codes and messages
 *
 * @see {@link StreamableHttpTransport} For HTTP transport implementation
 * @see {@link Middleware} For middleware function signature
 * @see {@link ToolCallResult} For tool return value format
 * @see {@link MCPServerContext} For request context interface
 */
export declare class McpServer {
    private methods;
    private initialized;
    private serverInfo;
    private middlewares;
    private capabilities;
    private onErrorHandler?;
    private schemaAdapter?;
    private logger;
    private tools;
    private prompts;
    private resources;
    private notificationSender?;
    private clientRequestSender?;
    /**
     * Create a new MCP server instance.
     *
     * @param options - Server configuration options
     * @param options.name - Server name (included in server info)
     * @param options.version - Server version (included in server info)
     *
     * @example
     * ```typescript
     * const server = new McpServer({
     *   name: "my-awesome-server",
     *   version: "1.2.3"
     * });
     * ```
     */
    constructor(options: McpServerOptions);
    /**
     * Add middleware to the server request pipeline.
     *
     * Middleware functions execute in the order they are added, before the actual
     * request handler. They can modify the context, implement authentication,
     * add logging, etc.
     *
     * @param middleware - Middleware function to add
     * @returns This server instance for chaining
     *
     * @example
     * ```typescript
     * server.use(async (ctx, next) => {
     *   console.log(`Received ${ctx.request.method} request`);
     *   ctx.state.startTime = Date.now();
     *   await next();
     *   console.log(`Request took ${Date.now() - ctx.state.startTime}ms`);
     *   if (ctx.response?.result) {
     *     console.log("Tool executed successfully:", ctx.response.result);
     *   }
     * });
     * ```
     */
    use(middleware: Middleware): this;
    /**
     * Set a custom error handler for the server.
     *
     * The error handler receives all unhandled errors and can return custom
     * JSON-RPC error responses or return undefined to use default error handling.
     *
     * @param handler - Error handler function
     * @returns This server instance for chaining
     *
     * @example
     * ```typescript
     * server.onError((error, ctx) => {
     *   if (error instanceof AuthError) {
     *     return {
     *       code: -32001,
     *       message: "Authentication required",
     *       data: { requestId: ctx.requestId }
     *     };
     *   }
     *   // Return undefined for default error handling
     * });
     * ```
     */
    onError(handler: OnError): this;
    /**
     * Register a tool that clients can call.
     *
     * Tools are functions exposed to MCP clients. They receive validated arguments
     * and must return content in the ToolCallResult format.
     *
     * @template TArgs - Type of the tool's input arguments
     * @template TOutput - Type of the structured content output
     * @param name - Unique tool name
     * @param def - Tool definition with schema, description, handler, and optional metadata
     * @param def.description - Human-readable description of what the tool does
     * @param def.title - Optional display title for the tool
     * @param def._meta - Optional arbitrary metadata object passed through to clients via tools/list
     * @param def.inputSchema - Schema for validating input arguments (JSON Schema or Standard Schema)
     * @param def.outputSchema - Schema for validating structured output (JSON Schema or Standard Schema)
     * @param def.handler - Function that executes the tool logic
     * @returns This server instance for chaining
     *
     * @example With JSON Schema
     * ```typescript
     * server.tool("calculateSum", {
     *   description: "Calculates the sum of two numbers",
     *   inputSchema: {
     *     type: "object",
     *     properties: {
     *       a: { type: "number" },
     *       b: { type: "number" }
     *     },
     *     required: ["a", "b"]
     *   },
     *   handler: (args: { a: number; b: number }) => ({
     *     content: [{ type: "text", text: String(args.a + args.b) }]
     *   })
     * });
     * ```
     *
     * @example With Standard Schema (Zod) - Full type inference
     * ```typescript
     * import { z } from "zod";
     *
     * const inputSchema = z.object({
     *   location: z.string()
     * });
     *
     * const outputSchema = z.object({
     *   temperature: z.number(),
     *   conditions: z.string()
     * });
     *
     * server.tool("getWeather", {
     *   description: "Get weather for a location",
     *   inputSchema,
     *   outputSchema,
     *   handler: (args) => ({
     *     // args.location is typed as string ✅
     *     content: [{ type: "text", text: "Weather data" }],
     *     structuredContent: {
     *       temperature: 22,
     *       conditions: "sunny"
     *       // Typed and validated! ✅
     *     }
     *   })
     * });
     * ```
     *
     * @example Without schema
     * ```typescript
     * server.tool("ping", {
     *   description: "Simple ping tool",
     *   handler: () => ({
     *     content: [{ type: "text", text: "pong" }]
     *   })
     * });
     * ```
     *
     * @example With metadata
     * ```typescript
     * server.tool("experimental-feature", {
     *   description: "An experimental feature",
     *   title: "Experimental Feature",
     *   _meta: {
     *     version: "0.1.0",
     *     stability: "experimental",
     *     tags: ["beta", "preview"]
     *   },
     *   inputSchema: z.object({ input: z.string() }),
     *   handler: (args) => ({
     *     content: [{ type: "text", text: `Processing: ${args.input}` }]
     *   })
     * });
     * ```
     */
    tool<SInput extends StandardSchemaV1<unknown, unknown>, SOutput extends StandardSchemaV1<unknown, unknown>>(name: string, def: {
        description?: string;
        title?: string;
        _meta?: {
            [key: string]: unknown;
        };
        inputSchema: SInput;
        outputSchema: SOutput;
        handler: (args: InferOutput<SInput>, ctx: MCPServerContext) => Promise<ToolCallResult<InferOutput<SOutput>>> | ToolCallResult<InferOutput<SOutput>>;
    }): this;
    tool<S extends StandardSchemaV1<unknown, unknown>>(name: string, def: {
        description?: string;
        title?: string;
        _meta?: {
            [key: string]: unknown;
        };
        inputSchema: S;
        outputSchema?: unknown;
        handler: (args: InferOutput<S>, ctx: MCPServerContext) => Promise<ToolCallResult> | ToolCallResult;
    }): this;
    tool<S extends StandardSchemaV1<unknown, unknown>>(name: string, def: {
        description?: string;
        title?: string;
        _meta?: {
            [key: string]: unknown;
        };
        inputSchema?: unknown;
        outputSchema: S;
        handler: (args: unknown, ctx: MCPServerContext) => Promise<ToolCallResult<InferOutput<S>>> | ToolCallResult<InferOutput<S>>;
    }): this;
    tool<TArgs = unknown, TOutput = unknown>(name: string, def: {
        description?: string;
        title?: string;
        _meta?: {
            [key: string]: unknown;
        };
        inputSchema?: unknown;
        outputSchema?: unknown;
        handler: (args: TArgs, ctx: MCPServerContext) => Promise<ToolCallResult<TOutput>> | ToolCallResult<TOutput>;
    }): this;
    /**
     * Register a resource that clients can list and read.
     *
     * Resources are URI-identified content that can be static or template-based.
     * Templates support parameter extraction using Hono-style syntax.
     *
     * @param template - URI template string (e.g. "file://config.json" or "github://repos/{owner}/{repo}")
     * @param meta - Resource metadata for listing
     * @param meta.name - Human-readable name for the resource
     * @param meta.description - Description of what the resource contains
     * @param meta.mimeType - MIME type of the resource content
     * @param meta._meta - Optional arbitrary metadata object passed through to clients via resources/list
     * @param meta.annotations - Optional annotations for the resource
     * @param handler - Function that returns resource content
     * @returns This server instance for chaining
     *
     * @example Static resource
     * ```typescript
     * server.resource(
     *   "file://config.json",
     *   { description: "App configuration", mimeType: "application/json" },
     *   async (uri) => ({
     *     contents: [{ uri: uri.href, text: JSON.stringify(config) }]
     *   })
     * );
     * ```
     *
     * @example Template resource
     * ```typescript
     * server.resource(
     *   "github://repos/{owner}/{repo}",
     *   { description: "GitHub repository" },
     *   async (uri, { owner, repo }) => ({
     *     contents: [{ uri: uri.href, text: await fetchRepo(owner, repo) }]
     *   })
     * );
     * ```
     *
     * @example Resource with metadata
     * ```typescript
     * server.resource(
     *   "db://records/{id}",
     *   {
     *     name: "Database Record",
     *     description: "Fetch a record from the database",
     *     mimeType: "application/json",
     *     _meta: {
     *       cacheTtl: 300,
     *       accessLevel: "read-only"
     *     }
     *   },
     *   async (uri, { id }) => ({
     *     contents: [{ uri: uri.href, text: JSON.stringify({ id, data: "..." }) }]
     *   })
     * );
     * ```
     */
    resource(template: string, meta: ResourceMeta, handler: ResourceHandler): this;
    /**
     * Register a resource with parameter validation.
     *
     * @param template - URI template string with variables
     * @param meta - Resource metadata for listing
     * @param validators - Parameter validators (StandardSchema-compatible)
     * @param handler - Function that returns resource content
     * @returns This server instance for chaining
     *
     * @example With validation
     * ```typescript
     * server.resource(
     *   "api://users/{userId}",
     *   { description: "User by ID" },
     *   { userId: z.string().regex(/^\d+$/) },
     *   async (uri, { userId }) => ({
     *     contents: [{ uri: uri.href, text: JSON.stringify(await getUser(userId)) }]
     *   })
     * );
     * ```
     */
    resource(template: string, meta: ResourceMeta, validators: ResourceVarValidators, handler: ResourceHandler): this;
    /**
     * Register a prompt that clients can invoke.
     *
     * Prompts are templates that generate messages for LLM conversations.
     * They can accept arguments and return a structured set of messages.
     *
     * @template TArgs - Type of the prompt's input arguments
     * @param name - Unique prompt name
     * @param def - Prompt definition with schema, description, handler, and optional metadata
     * @param def.description - Human-readable description of what the prompt does
     * @param def.title - Optional display title for the prompt
     * @param def._meta - Optional arbitrary metadata object passed through to clients via prompts/list
     * @param def.arguments - Array of argument definitions or a Standard Schema for validation
     * @param def.inputSchema - Alternative to 'arguments' for specifying a validation schema
     * @param def.handler - Function that generates the prompt messages
     * @returns This server instance for chaining
     *
     * @example Basic prompt
     * ```typescript
     * server.prompt("greet", {
     *   description: "Generate a greeting message",
     *   handler: () => ({
     *     messages: [{
     *       role: "user",
     *       content: { type: "text", text: "Hello, how are you?" }
     *     }]
     *   })
     * });
     * ```
     *
     * @example Prompt with arguments and schema
     * ```typescript
     * server.prompt("summarize", {
     *   description: "Create a summary prompt",
     *   arguments: z.object({
     *     text: z.string(),
     *     length: z.enum(["short", "medium", "long"]).optional()
     *   }),
     *   handler: (args: { text: string; length?: string }) => ({
     *     description: "Summarization prompt",
     *     messages: [{
     *       role: "user",
     *       content: {
     *         type: "text",
     *         text: `Please summarize this text in ${args.length || "medium"} length:\n\n${args.text}`
     *       }
     *     }]
     *   })
     * });
     * ```
     *
     * @example Prompt with metadata
     * ```typescript
     * server.prompt("research-assistant", {
     *   description: "Research assistant prompt with context",
     *   title: "Research Assistant",
     *   _meta: {
     *     category: "research",
     *     complexity: "advanced",
     *     estimatedTokens: 500
     *   },
     *   arguments: [
     *     { name: "topic", description: "Research topic", required: true }
     *   ],
     *   handler: (args: { topic: string }) => ({
     *     messages: [{
     *       role: "user",
     *       content: { type: "text", text: `Research ${args.topic}` }
     *     }]
     *   })
     * });
     * ```
     */
    prompt<TArgs = unknown>(name: string, def: {
        title?: string;
        description?: string;
        _meta?: {
            [key: string]: unknown;
        };
        arguments?: unknown | StandardSchemaV1<TArgs>;
        inputSchema?: unknown | StandardSchemaV1<TArgs>;
        handler: PromptHandler<TArgs>;
    }): this;
    /**
     * Mount a child server into this parent server for composition.
     *
     * Enables modular server design by composing multiple McpServer instances.
     * Uses keep-first semantics: first registered tool/prompt/resource wins,
     * later duplicates are silently skipped.
     *
     * @param child - Child server to mount (flat, no namespacing)
     * @returns This server instance for chaining
     *
     * @see {@link Logger} For configuring logging to track duplicate warnings
     * @see {@link Middleware} For middleware composition behavior
     *
     * @example Flat mounting (no namespacing)
     * ```typescript
     * const git = new McpServer({ name: 'git', version: '1.0.0' })
     *   .tool('clone', { handler: cloneHandler });
     *
     * const app = new McpServer({ name: 'app', version: '1.0.0' })
     *   .group(git);  // tools/list shows 'clone'
     * ```
     *
     * @example Complete example
     * See examples/composing-servers for a full working example with multiple
     * child servers, middleware composition, and real-world patterns.
     */
    group(child: McpServer): this;
    /**
     * Mount a child server with namespaced tools and prompts.
     *
     * @param prefix - Namespace prefix (e.g., 'git' makes 'clone' → 'git/clone')
     * @param child - Child server to mount
     * @returns This server instance for chaining
     *
     * @see {@link Logger} For configuring logging to track duplicate warnings
     * @see {@link Middleware} For middleware composition behavior
     *
     * @example Prefix namespacing
     * ```typescript
     * const git = new McpServer({ name: 'git', version: '1.0.0' })
     *   .tool('clone', { handler: cloneHandler });
     *
     * const app = new McpServer({ name: 'app', version: '1.0.0' })
     *   .group('git', git);  // tools/list shows 'git/clone'
     * ```
     *
     * @example Complete example
     * See examples/composing-servers for a full working example with multiple
     * child servers, middleware composition, and real-world patterns.
     */
    group(prefix: string, child: McpServer): this;
    /**
     * Mount a child server with flexible namespacing options.
     *
     * @param options - Namespacing configuration
     * @param child - Child server to mount
     * @returns This server instance for chaining
     *
     * @see {@link Logger} For configuring logging to track duplicate warnings
     * @see {@link Middleware} For middleware composition behavior
     *
     * @example Suffix namespacing
     * ```typescript
     * const claude = new McpServer({ name: 'claude', version: '1.0.0' })
     *   .tool('generateText', { handler: claudeHandler });
     *
     * const app = new McpServer({ name: 'app', version: '1.0.0' })
     *   .group({ suffix: 'claude' }, claude);  // tools/list shows 'generateText_claude'
     * ```
     *
     * @example Both prefix and suffix
     * ```typescript
     * .group({ prefix: 'ai', suffix: 'v2' }, server);  // 'ai/generateText_v2'
     * ```
     */
    group(options: {
        prefix?: string;
        suffix?: string;
    }, child: McpServer): this;
    /**
     * Export registries snapshot for child server mounting.
     * Used internally by .group() to compose servers.
     * @internal
     */
    protected _exportRegistries(): {
        tools: Array<{
            name: string;
            entry: ToolEntry;
        }>;
        prompts: Array<{
            name: string;
            entry: PromptEntry;
        }>;
        resources: Array<{
            template: string;
            entry: ResourceEntry;
        }>;
    };
    /**
     * Export middlewares snapshot for child server mounting.
     * Used internally by .group() to compose middleware chains.
     * @internal
     */
    protected _exportMiddlewares(): Middleware[];
    /**
     * Wrap a tool or prompt handler with child middlewares for composition.
     * Ensures child middlewares run around the handler while parent middlewares
     * run around the entire wrapped handler.
     * @internal
     */
    private wrapWithMiddlewares;
    /**
     * Wrap a resource handler with child middlewares for composition.
     * Ensures child middlewares run around the handler while parent middlewares
     * run around the entire wrapped handler.
     * @internal
     */
    private wrapResourceHandler;
    /**
     * Mount a child server into this parent server.
     * Implements keep-first semantics: first registered tool/prompt/resource wins,
     * duplicates are silently skipped.
     * @internal
     */
    private mountChild;
    /**
     * Set the notification sender for streaming notifications.
     * This is called by the transport to wire up notification delivery.
     */
    _setNotificationSender(sender: (sessionId: string | undefined, notification: {
        method: string;
        params?: unknown;
    }, options?: {
        relatedRequestId?: string;
    }) => Promise<void> | void): void;
    /**
     * Set the client request sender for elicitation and other client requests.
     * This is called by the transport to wire up client request delivery.
     */
    _setClientRequestSender(sender: (sessionId: string | undefined, request: JsonRpcReq, options?: {
        relatedRequestId?: string | number;
        timeout_ms?: number;
    }) => Promise<JsonRpcRes>): void;
    _dispatch(message: JsonRpcReq | JsonRpcNotification, contextOptions?: CreateContextOptions): Promise<JsonRpcRes | null>;
    private handleToolsList;
    private handleToolsCall;
    private handlePromptsList;
    private handlePromptsGet;
    private handleResourcesList;
    private handleResourceTemplatesList;
    private handleResourcesRead;
    private handleInitialize;
    private handlePing;
    private handleNotificationCancelled;
    private handleNotificationInitialized;
    private handleNotificationProgress;
    private handleNotificationRootsListChanged;
    private handleLoggingSetLevel;
    private handleNotImplemented;
}
//# sourceMappingURL=core.d.ts.map