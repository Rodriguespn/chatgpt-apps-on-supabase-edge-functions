"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const l="mcpui.dev/ui-",c=`"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/adapters/appssdk/adapter-runtime.ts
  var MCPUIAppsSdkAdapter = class {
    constructor(config = {}) {
      __publicField(this, "config");
      __publicField(this, "pendingRequests", /* @__PURE__ */ new Map());
      __publicField(this, "messageIdCounter", 0);
      __publicField(this, "originalPostMessage", null);
      this.config = {
        logger: config.logger || console,
        hostOrigin: config.hostOrigin || window.location.origin,
        timeout: config.timeout || 3e4,
        intentHandling: config.intentHandling || "prompt"
      };
    }
    /**
     * Initialize the adapter and monkey-patch postMessage if Apps SDK is present
     */
    install() {
      if (!window.openai) {
        this.config.logger.warn("[MCPUI-Apps SDK Adapter] window.openai not detected. Adapter will not activate.");
        return false;
      }
      this.config.logger.log("[MCPUI-Apps SDK Adapter] Initializing adapter...");
      this.patchPostMessage();
      this.setupAppsSdkEventListeners();
      this.sendRenderData();
      this.config.logger.log("[MCPUI-Apps SDK Adapter] Adapter initialized successfully");
      return true;
    }
    /**
     * Clean up pending requests and restore original postMessage
     */
    uninstall() {
      for (const request of this.pendingRequests.values()) {
        clearTimeout(request.timeoutId);
        request.reject(new Error("Adapter uninstalled"));
      }
      this.pendingRequests.clear();
      if (this.originalPostMessage) {
        try {
          const originalPostMessage = this.originalPostMessage;
          window.parent.postMessage = originalPostMessage;
          this.config.logger.log("[MCPUI-Apps SDK Adapter] Restored original parent.postMessage");
        } catch (error) {
          this.config.logger.error("[MCPUI-Apps SDK Adapter] Failed to restore original postMessage:", error);
        }
      }
      this.config.logger.log("[MCPUI-Apps SDK Adapter] Adapter uninstalled");
    }
    /**
     * Monkey-patch parent.postMessage to intercept MCP-UI messages
     * and forward non-MCP-UI messages to the original postMessage
     */
    patchPostMessage() {
      this.originalPostMessage = window.parent?.postMessage?.bind(window.parent) || null;
      if (!this.originalPostMessage) {
        this.config.logger.debug("[MCPUI-Apps SDK Adapter] parent.postMessage does not exist, installing shim only");
      } else {
        this.config.logger.debug("[MCPUI-Apps SDK Adapter] Monkey-patching parent.postMessage to intercept MCP-UI messages");
      }
      const postMessageInterceptor = (message, targetOrigin, transfer) => {
        if (this.isMCPUIMessage(message)) {
          const mcpMessage = message;
          this.config.logger.debug("[MCPUI-Apps SDK Adapter] Intercepted MCP-UI message:", mcpMessage.type);
          this.handleMCPUIMessage(mcpMessage);
        } else {
          if (this.originalPostMessage) {
            this.config.logger.debug("[MCPUI-Apps SDK Adapter] Forwarding non-MCP-UI message to original postMessage");
            this.originalPostMessage(message, targetOrigin ?? "*", transfer);
          } else {
            this.config.logger.warn("[MCPUI-Apps SDK Adapter] No original postMessage to forward to, ignoring message:", message);
          }
        }
      };
      try {
        window.parent.postMessage = postMessageInterceptor;
      } catch (error) {
        this.config.logger.error("[MCPUI-Apps SDK Adapter] Failed to monkey-patch parent.postMessage:", error);
      }
    }
    /**
     * Check if a message is an MCP-UI protocol message
     */
    isMCPUIMessage(message) {
      if (!message || typeof message !== "object") {
        return false;
      }
      const msg = message;
      return typeof msg.type === "string" && (msg.type.startsWith("ui-") || ["tool", "prompt", "intent", "notify", "link"].includes(msg.type));
    }
    /**
     * Handle incoming MCP-UI messages and translate to Apps SDK actions
     */
    async handleMCPUIMessage(message) {
      this.config.logger.debug("[MCPUI-Apps SDK Adapter] Received MCPUI message:", message.type);
      try {
        switch (message.type) {
          case "tool":
            await this.handleToolMessage(message);
            break;
          case "prompt":
            await this.handlePromptMessage(message);
            break;
          case "intent":
            await this.handleIntentMessage(message);
            break;
          case "notify":
            await this.handleNotifyMessage(message);
            break;
          case "link":
            await this.handleLinkMessage(message);
            break;
          case "ui-lifecycle-iframe-ready":
            this.sendRenderData();
            break;
          case "ui-request-render-data":
            this.sendRenderData(message.messageId);
            break;
          case "ui-size-change":
            this.handleSizeChange(message);
            break;
          case "ui-request-data":
            this.handleRequestData(message);
            break;
          default:
            this.config.logger.warn("[MCPUI-Apps SDK Adapter] Unknown message type:", message.type);
        }
      } catch (error) {
        this.config.logger.error("[MCPUI-Apps SDK Adapter] Error handling message:", error);
        if (message.messageId) {
          this.sendErrorResponse(message.messageId, error);
        }
      }
    }
    /**
     * Handle 'tool' message - call Apps SDK tool
     */
    async handleToolMessage(message) {
      if (message.type !== "tool")
        return;
      const { toolName, params } = message.payload;
      const messageId = message.messageId || this.generateMessageId();
      this.sendAcknowledgment(messageId);
      try {
        if (!window.openai?.callTool) {
          throw new Error("Tool calling is not supported in this environment");
        }
        const result = await this.withTimeout(
          window.openai.callTool(toolName, params),
          messageId
        );
        this.sendSuccessResponse(messageId, result);
      } catch (error) {
        this.sendErrorResponse(messageId, error);
      }
    }
    /**
     * Handle 'prompt' message - send followup turn
     */
    async handlePromptMessage(message) {
      if (message.type !== "prompt")
        return;
      const prompt = message.payload.prompt;
      const messageId = message.messageId || this.generateMessageId();
      this.sendAcknowledgment(messageId);
      try {
        if (!window.openai?.sendFollowUpMessage) {
          throw new Error("Followup turns are not supported in this environment");
        }
        await this.withTimeout(
          window.openai.sendFollowUpMessage({ prompt }),
          messageId
        );
        this.sendSuccessResponse(messageId, { success: true });
      } catch (error) {
        this.sendErrorResponse(messageId, error);
      }
    }
    /**
     * Handle 'intent' message - convert to prompt or ignore based on config
     */
    async handleIntentMessage(message) {
      if (message.type !== "intent")
        return;
      const messageId = message.messageId || this.generateMessageId();
      this.sendAcknowledgment(messageId);
      if (this.config.intentHandling === "ignore") {
        this.config.logger.log("[MCPUI-Apps SDK Adapter] Intent ignored:", message.payload.intent);
        this.sendSuccessResponse(messageId, { ignored: true });
        return;
      }
      const { intent, params } = message.payload;
      const prompt = \`\${intent}\${params ? \`: \${JSON.stringify(params)}\` : ""}\`;
      try {
        if (!window.openai?.sendFollowUpMessage) {
          throw new Error("Followup turns are not supported in this environment");
        }
        await this.withTimeout(
          window.openai.sendFollowUpMessage({ prompt }),
          messageId
        );
        this.sendSuccessResponse(messageId, { success: true });
      } catch (error) {
        this.sendErrorResponse(messageId, error);
      }
    }
    /**
     * Handle 'notify' message - log only
     */
    async handleNotifyMessage(message) {
      if (message.type !== "notify")
        return;
      const messageId = message.messageId || this.generateMessageId();
      this.config.logger.log("[MCPUI-Apps SDK Adapter] Notification:", message.payload.message);
      this.sendAcknowledgment(messageId);
      this.sendSuccessResponse(messageId, { acknowledged: true });
    }
    /**
     * Handle 'link' message - not supported in Apps SDK environments
     */
    async handleLinkMessage(message) {
      if (message.type !== "link")
        return;
      const messageId = message.messageId || this.generateMessageId();
      this.sendAcknowledgment(messageId);
      this.sendErrorResponse(messageId, new Error("Navigation is not supported in Apps SDK environment"));
    }
    /**
     * Handle size change - no-op in Apps SDK environment
     */
    handleSizeChange(message) {
      this.config.logger.debug("[MCPUI-Apps SDK Adapter] Size change requested (no-op in Apps SDK):", message.payload);
    }
    /**
     * Handle generic data request
     */
    handleRequestData(message) {
      const messageId = message.messageId || this.generateMessageId();
      this.sendAcknowledgment(messageId);
      this.sendErrorResponse(messageId, new Error("Generic data requests not yet implemented"));
    }
    /**
     * Setup listeners for Apps SDK events
     */
    setupAppsSdkEventListeners() {
      window.addEventListener("openai:set_globals", () => {
        this.config.logger.debug("[MCPUI-Apps SDK Adapter] Globals updated");
        this.sendRenderData();
      });
    }
    /**
     * Gather render data from Apps SDK and send to widget
     */
    sendRenderData(requestMessageId) {
      if (!window.openai)
        return;
      const renderData = {
        toolInput: window.openai.toolInput,
        toolOutput: window.openai.toolOutput,
        widgetState: window.openai.widgetState,
        locale: window.openai.locale || "en-US",
        theme: window.openai.theme || "light",
        displayMode: window.openai.displayMode || "inline",
        maxHeight: window.openai.maxHeight
      };
      this.dispatchMessageToIframe({
        type: "ui-lifecycle-iframe-render-data",
        messageId: requestMessageId,
        payload: { renderData }
      });
    }
    /**
     * Send acknowledgment for a message
     */
    sendAcknowledgment(messageId) {
      this.dispatchMessageToIframe({
        type: "ui-message-received",
        payload: { messageId }
      });
    }
    /**
     * Send success response
     */
    sendSuccessResponse(messageId, response) {
      this.dispatchMessageToIframe({
        type: "ui-message-response",
        payload: { messageId, response }
      });
    }
    /**
     * Send error response
     */
    sendErrorResponse(messageId, error) {
      const errorObj = error instanceof Error ? { message: error.message, name: error.name } : { message: String(error) };
      this.dispatchMessageToIframe({
        type: "ui-message-response",
        payload: { messageId, error: errorObj }
      });
    }
    /**
     * Dispatch a MessageEvent to the iframe (widget)
     * Simulates messages that would normally come from the parent/host
     */
    dispatchMessageToIframe(data) {
      const event = new MessageEvent("message", {
        data,
        origin: this.config.hostOrigin,
        source: null
      });
      window.dispatchEvent(event);
    }
    /**
     * Wrap a promise with timeout
     */
    async withTimeout(promise, requestId) {
      return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          this.pendingRequests.delete(requestId);
          reject(new Error(\`Request timed out after \${this.config.timeout}ms\`));
        }, this.config.timeout);
        this.pendingRequests.set(requestId, {
          messageId: requestId,
          type: "generic",
          resolve,
          reject,
          timeoutId
        });
        promise.then((result) => {
          clearTimeout(timeoutId);
          this.pendingRequests.delete(requestId);
          resolve(result);
        }).catch((error) => {
          clearTimeout(timeoutId);
          this.pendingRequests.delete(requestId);
          reject(error);
        });
      });
    }
    /**
     * Generate a unique message ID
     */
    generateMessageId() {
      return \`adapter-\${Date.now()}-\${++this.messageIdCounter}\`;
    }
  };
  var adapterInstance = null;
  function initAdapter(config) {
    if (adapterInstance) {
      console.warn("[MCPUI-Apps SDK Adapter] Adapter already initialized");
      return true;
    }
    adapterInstance = new MCPUIAppsSdkAdapter(config);
    return adapterInstance.install();
  }
  function uninstallAdapter() {
    if (adapterInstance) {
      adapterInstance.uninstall();
      adapterInstance = null;
    }
  }
  if (typeof window !== "undefined" && !window.MCP_APPSSDK_ADAPTER_NO_AUTO_INSTALL) {
    initAdapter();
  }
})();
`;function d(e){const t=e?JSON.stringify(e):"{}";return`
<script>
(function() {
  'use strict';
  
  ${c}
  
  // Override auto-init from runtime and initialize with provided config
  if (typeof window !== 'undefined') {
    window.MCP_APPSSDK_ADAPTER_NO_AUTO_INSTALL = true; // Prevent auto-init from bundled code
    
    // Initialize with config from server
    if (typeof initAdapter === 'function') {
      initAdapter(${t});
    }
    
    // Expose functions globally
    if (typeof window.MCPUIAppsSdkAdapter === 'undefined') {
      window.MCPUIAppsSdkAdapter = {
        init: initAdapter,
        uninstall: uninstallAdapter,
      };
    }
  }
})();
<\/script>
`.trim()}function o(e){const t={...e.resourceProps??{}};if(e.uiMetadata||e.metadata){const s=Object.fromEntries(Object.entries(e.uiMetadata??{}).map(([a,n])=>[`${l}${a}`,n]));t._meta={...s,...e.metadata??{},...t._meta??{}}}return t}function m(e){if(typeof Buffer<"u")return Buffer.from(e,"utf-8").toString("base64");if(typeof TextEncoder<"u"&&typeof btoa<"u"){const s=new TextEncoder().encode(e);let a="";const n=8192;for(let r=0;r<s.length;r+=n)a+=String.fromCharCode(...s.slice(r,r+n));return btoa(a)}else{console.warn("MCP-UI SDK: Buffer API and TextEncoder/btoa not available. Base64 encoding might not be UTF-8 safe.");try{return btoa(e)}catch{throw new Error("MCP-UI SDK: Suitable UTF-8 to Base64 encoding method not found, and fallback btoa failed.")}}}function g(e,t){if(!t)return{htmlContent:e};const s=e,a=[];let n;if(t.appsSdk?.enabled){const p=d(t.appsSdk.config);a.push(p),n||(n=t.appsSdk.mimeType??"text/html+skybridge")}if(a.length===0)return{htmlContent:e};const r=a.join(`
`);let i;return s.includes("<head>")?i=s.replace("<head>",`<head>
${r}`):s.includes("<html>")?i=s.replace("<html>",`<html>
<head>
${r}
</head>`):i=`${r}
${s}`,{htmlContent:i,mimeType:n}}function u(e){let t,s;if(e.content.type==="rawHtml"){if(!e.uri.startsWith("ui://"))throw new Error("MCP-UI SDK: URI must start with 'ui://' when content.type is 'rawHtml'.");if(t=e.content.htmlString,typeof t!="string")throw new Error("MCP-UI SDK: content.htmlString must be provided as a string when content.type is 'rawHtml'.");if(e.adapters){const n=g(t,e.adapters);t=n.htmlContent,s=n.mimeType??"text/html"}else s="text/html"}else if(e.content.type==="externalUrl"){if(!e.uri.startsWith("ui://"))throw new Error("MCP-UI SDK: URI must start with 'ui://' when content.type is 'externalUrl'.");if(t=e.content.iframeUrl,typeof t!="string")throw new Error("MCP-UI SDK: content.iframeUrl must be provided as a string when content.type is 'externalUrl'.");s="text/uri-list"}else if(e.content.type==="remoteDom"){if(!e.uri.startsWith("ui://"))throw new Error("MCP-UI SDK: URI must start with 'ui://' when content.type is 'remoteDom'.");if(t=e.content.script,typeof t!="string")throw new Error("MCP-UI SDK: content.script must be provided as a string when content.type is 'remoteDom'.");s=`application/vnd.mcp-ui.remote-dom+javascript; framework=${e.content.framework}`}else{const n=e.content;throw new Error(`MCP-UI SDK: Invalid content.type specified: ${n}`)}let a;switch(e.encoding){case"text":a={uri:e.uri,mimeType:s,text:t,...o(e)};break;case"blob":a={uri:e.uri,mimeType:s,blob:m(t),...o(e)};break;default:{const n=e.encoding;throw new Error(`MCP-UI SDK: Invalid encoding type: ${n}`)}}return{type:"resource",resource:a,...e.embeddedResourceProps??{}}}function h(e){window.parent&&window.parent.postMessage(e,"*")}const f={UI_MESSAGE_RECEIVED:"ui-message-received",UI_MESSAGE_RESPONSE:"ui-message-response",UI_SIZE_CHANGE:"ui-size-change",UI_LIFECYCLE_IFRAME_READY:"ui-lifecycle-iframe-ready",UI_LIFECYCLE_IFRAME_RENDER_DATA:"ui-lifecycle-iframe-render-data"},I={WAIT_FOR_RENDER_DATA:"waitForRenderData"};function w(e,t){return{type:"tool",payload:{toolName:e,params:t}}}function M(e){return{type:"prompt",payload:{prompt:e}}}function y(e){return{type:"link",payload:{url:e}}}function A(e,t){return{type:"intent",payload:{intent:e,params:t}}}function S(e){return{type:"notify",payload:{message:e}}}exports.InternalMessageType=f;exports.ReservedUrlParams=I;exports.createUIResource=u;exports.getAppsSdkAdapterScript=d;exports.postUIActionResult=h;exports.uiActionResultIntent=A;exports.uiActionResultLink=y;exports.uiActionResultNotification=S;exports.uiActionResultPrompt=M;exports.uiActionResultToolCall=w;exports.wrapHtmlWithAdapters=g;
//# sourceMappingURL=index.cjs.map
